// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2019.2.0.dev0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'auto'
//  split:                          False

#ifndef __DUAL2D_H
#define __DUAL2D_H
#include <algorithm>
#include <cmath>
#include <iostream>
#include <stdexcept>
#include <ufc.h>

class dual2d_finite_element_0: public ufc::finite_element
{
public:

  dual2d_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Lagrange', triangle, 1)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 3;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[3 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 3 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[3] = {};
    const std::size_t num_components[3] = { 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 3; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[3 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 3 * num_derivatives, 0.0);
    const std::size_t reference_offsets[3] = {};
    const std::size_t physical_offsets[3] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 3; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[3 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[3 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[3];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[3];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 3, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 3; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[6] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 6, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_0();
  }

};


class dual2d_finite_element_1: public ufc::finite_element
{
public:

  dual2d_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 6;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 2;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 2;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 6 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[6 * 2 * ip + 2 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives * 2, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 6; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 6 * num_derivatives * 2, 0.0);
    const std::size_t reference_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    const std::size_t physical_offsets[6] = { 0, 0, 0, 1, 1, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[6 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[12];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[12];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[3] = dof_values[4];
    vertex_values[5] = dof_values[5];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 2;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_0();
    case 1:
        return new dual2d_finite_element_0();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_1();
  }

};


class dual2d_finite_element_2: public ufc::finite_element
{
public:

  dual2d_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Lagrange', triangle, 2)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 6;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 2;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients1[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients2[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients3[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients4[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients5[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    for (std::size_t k = 0; k < num_points * 6; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[6 * ip] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[6 * ip + 1] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[6 * ip + 2] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[6 * ip + 3] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[6 * ip + 4] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[6 * ip + 5] += coefficients5[0][r] * basisvalues2[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 6 * num_derivatives, 0.0);
    if (order > 2)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][6][6] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
            { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
            { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
            { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients1[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients2[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients3[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients4[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients5[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    const std::size_t reference_offset[6] = {};
    const std::size_t num_components[6] = { 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 6; ++i)
        {
            double derivatives[4] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[6 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    std::fill_n(values, num_points * 6 * num_derivatives, 0.0);
    const std::size_t reference_offsets[6] = {};
    const std::size_t physical_offsets[6] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[4][4];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 6; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[6 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[6 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[6];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[6];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    // Declare transformation matrix
    double transform[4][4] =
        { { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 6, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 6; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 3 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 4 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 5 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[12] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_2();
  }

};


class dual2d_finite_element_3: public ufc::finite_element
{
public:

  dual2d_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 12;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 2;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 2 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 2;
  }

  std::size_t degree() const final override
  {
    return 2;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients1[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients2[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients3[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients4[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients5[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    for (std::size_t k = 0; k < num_points * 12 * 2; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 2] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 3] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 4] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 5] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 6 + 1] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 7 + 1] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 8 + 1] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 9 + 1] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 10 + 1] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[12 * 2 * ip + 2 * 11 + 1] += coefficients5[0][r] * basisvalues2[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 12 * num_derivatives * 2, 0.0);
    if (order > 2)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][6][6] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
            { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
            { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
            { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients1[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients2[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients3[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients4[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients5[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    const std::size_t reference_offset[12] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
    const std::size_t num_components[12] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 12; ++i)
        {
            double derivatives[4] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[12 * (num_derivatives * 2) * ip + num_derivatives * 2 * i + 2 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    std::fill_n(values, num_points * 12 * num_derivatives * 2, 0.0);
    const std::size_t reference_offsets[12] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
    const std::size_t physical_offsets[12] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[4][4];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 12; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[12 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[12 * (num_derivatives * 2) * ip + num_derivatives * 2 * d + 2 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[24];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[24];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 2; ++k)
        values[k] = physical_values[2 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 12; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2; ++s)
            values[r * 2 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 2 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    // Declare transformation matrix
    double transform[4][4] =
        { { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 2 * num_derivatives * 12, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[8] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 12; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 2 * num_derivatives; ++s)
            values[2 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 11:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[2];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 3 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 4 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 5 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 6] = coordinate_dofs[0];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 7] = coordinate_dofs[2];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 8] = coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 9] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 9 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 10 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 11] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 11 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[24] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0 };
    std::copy_n(dof_X, 24, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 2;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_2();
    case 1:
        return new dual2d_finite_element_2();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_3();
  }

};


class dual2d_finite_element_4: public ufc::finite_element
{
public:

  dual2d_finite_element_4() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_4() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "MixedElement(VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1))";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 18;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 4 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 4;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 4 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 4;
  }

  std::size_t degree() const final override
  {
    return 2;
  }

  const char * family() const final override
  {
    return "Mixed";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients1[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients2[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients3[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients4[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients5[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    static const double coefficients12[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients13[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients14[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 18 * 4; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 2] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 3] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 4] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 5] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 6 + 1] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 7 + 1] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 8 + 1] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 9 + 1] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 10 + 1] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[18 * 4 * ip + 4 * 11 + 1] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[18 * 4 * ip + 4 * 12 + 2] += coefficients12[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[18 * 4 * ip + 4 * 13 + 2] += coefficients13[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[18 * 4 * ip + 4 * 14 + 2] += coefficients14[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[18 * 4 * ip + 4 * 15 + 3] += coefficients12[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[18 * 4 * ip + 4 * 16 + 3] += coefficients13[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[18 * 4 * ip + 4 * 17 + 3] += coefficients14[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 18 * num_derivatives * 4, 0.0);
    if (order > 2)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][6][6] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
            { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
            { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
            { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } } };
    alignas(32) static const double dmats12[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients1[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients2[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients3[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients4[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients5[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    static const double coefficients12[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients13[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients14[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[18] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3 };
    const std::size_t num_components[18] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 18; ++i)
        {
            double derivatives[4] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            case 15:
                // Compute reference derivatives for dof 15.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 16:
                // Compute reference derivatives for dof 16.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 17:
                // Compute reference derivatives for dof 17.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[18 * (num_derivatives * 4) * ip + num_derivatives * 4 * i + 4 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    std::fill_n(values, num_points * 18 * num_derivatives * 4, 0.0);
    const std::size_t reference_offsets[18] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3 };
    const std::size_t physical_offsets[18] = { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[4][4];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 18; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[18 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[18 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[72];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[72];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 4; ++k)
        values[k] = physical_values[4 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 18; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 4; ++s)
            values[r * 4 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 4 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    // Declare transformation matrix
    double transform[4][4] =
        { { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 15:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 16:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 17:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 4 * num_derivatives * 18, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[16] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 18; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 4 * num_derivatives; ++s)
            values[4 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[4];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 10:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 11:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 12:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 13:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 14:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 15:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 16:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 17:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[4];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[15] = vals[3];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[16] = vals[3];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[17] = vals[3];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[4] = dof_values[1];
    vertex_values[8] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[5] = dof_values[7];
    vertex_values[9] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[6] = dof_values[13];
    vertex_values[10] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[15];
    vertex_values[7] = dof_values[16];
    vertex_values[11] = dof_values[17];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 3 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 4] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 4 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 5] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 5 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 6] = coordinate_dofs[0];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 7] = coordinate_dofs[2];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 8] = coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 9] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 9 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 10] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 10 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 11] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 11 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 12] = coordinate_dofs[0];
    dof_coordinates[2 * 12 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 13] = coordinate_dofs[2];
    dof_coordinates[2 * 13 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 14] = coordinate_dofs[4];
    dof_coordinates[2 * 14 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 15] = coordinate_dofs[0];
    dof_coordinates[2 * 15 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 16] = coordinate_dofs[2];
    dof_coordinates[2 * 16 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 17] = coordinate_dofs[4];
    dof_coordinates[2 * 17 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[36] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 36, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 3;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_3();
    case 1:
        return new dual2d_finite_element_0();
    case 2:
        return new dual2d_finite_element_0();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_4();
  }

};


class dual2d_finite_element_5: public ufc::finite_element
{
public:

  dual2d_finite_element_5() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_5() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "TensorElement(FiniteElement('Lagrange', triangle, 1), shape=(2, 2), symmetry={})";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 12;
  }

  std::size_t value_rank() const final override
  {
    return 2;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[2] = { 2, 2 };
    if (i >= 2)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 4;
  }

  std::size_t reference_value_rank() const final override
  {
    return 2;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[2] = { 2, 2 };
    if (i >= 2)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 4;
  }

  std::size_t degree() const final override
  {
    return 1;
  }

  const char * family() const final override
  {
    return "Lagrange";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    for (std::size_t k = 0; k < num_points * 12 * 4; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 6 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 7 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 8 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 9 + 3] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 10 + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[12 * 4 * ip + 4 * 11 + 3] += coefficients2[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 12 * num_derivatives * 4, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    const std::size_t reference_offset[12] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3 };
    const std::size_t num_components[12] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        // Loop over all dofs
        for (std::size_t i = 0; i < 12; ++i)
        {
            double derivatives[2] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[12 * (num_derivatives * 4) * ip + num_derivatives * 4 * i + 4 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    std::fill_n(values, num_points * 12 * num_derivatives * 4, 0.0);
    const std::size_t reference_offsets[12] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3 };
    const std::size_t physical_offsets[12] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[2][2];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 12; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[12 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[12 * (num_derivatives * 4) * ip + num_derivatives * 4 * d + 4 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[48];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[48];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 4; ++k)
        values[k] = physical_values[4 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[4] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 12; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 4; ++s)
            values[r * 4 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 4 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][2][1] =
        { { { 0 },
            { 1 } } };
    // Declare transformation matrix
    double transform[2][2] =
        { { 1.0, 1.0 },
          { 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[2] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 4 * num_derivatives * 12, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[8] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 12; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 4 * num_derivatives; ++s)
            values[4 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[4];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 9:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[4];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[2];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[7] = vals[2];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[3];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[10] = vals[3];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[11] = vals[3];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[4] = dof_values[1];
    vertex_values[8] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[5] = dof_values[4];
    vertex_values[9] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[6];
    vertex_values[6] = dof_values[7];
    vertex_values[10] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[9];
    vertex_values[7] = dof_values[10];
    vertex_values[11] = dof_values[11];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 6] = coordinate_dofs[0];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 7] = coordinate_dofs[2];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 8] = coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 9] = coordinate_dofs[0];
    dof_coordinates[2 * 9 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 10] = coordinate_dofs[2];
    dof_coordinates[2 * 10 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 11] = coordinate_dofs[4];
    dof_coordinates[2 * 11 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[24] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 24, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 4;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_0();
    case 1:
        return new dual2d_finite_element_0();
    case 2:
        return new dual2d_finite_element_0();
    case 3:
        return new dual2d_finite_element_0();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_5();
  }

};


class dual2d_finite_element_6: public ufc::finite_element
{
public:

  dual2d_finite_element_6() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_6() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "MixedElement(TensorElement(FiniteElement('Lagrange', triangle, 1), shape=(2, 2), symmetry={}), VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2), VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2), FiniteElement('Lagrange', triangle, 1))";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 39;
  }

  std::size_t value_rank() const final override
  {
    return 1;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 9 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t value_size() const final override
  {
    return 9;
  }

  std::size_t reference_value_rank() const final override
  {
    return 1;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    static const int return_values[1] = { 9 };
    if (i >= 1)
        return 1;
    return return_values[i];
  }

  std::size_t reference_value_size() const final override
  {
    return 9;
  }

  std::size_t degree() const final override
  {
    return 2;
  }

  const char * family() const final override
  {
    return "Mixed";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    static const double coefficients12[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients13[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients14[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients15[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients16[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients17[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    for (std::size_t k = 0; k < num_points * 39 * 9; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 3 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 4 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 5 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 6 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 7 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 8 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 9 + 3] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 10 + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 11 + 3] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 12 + 4] += coefficients12[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 13 + 4] += coefficients13[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 14 + 4] += coefficients14[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 15 + 4] += coefficients15[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 16 + 4] += coefficients16[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 17 + 4] += coefficients17[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 18 + 5] += coefficients12[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 19 + 5] += coefficients13[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 20 + 5] += coefficients14[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 21 + 5] += coefficients15[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 22 + 5] += coefficients16[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 23 + 5] += coefficients17[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 24 + 6] += coefficients12[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 25 + 6] += coefficients13[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 26 + 6] += coefficients14[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 27 + 6] += coefficients15[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 28 + 6] += coefficients16[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 29 + 6] += coefficients17[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 30 + 7] += coefficients12[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 31 + 7] += coefficients13[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 32 + 7] += coefficients14[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 33 + 7] += coefficients15[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 34 + 7] += coefficients16[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 6; ++r)
            reference_values[39 * 9 * ip + 9 * 35 + 7] += coefficients17[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 36 + 8] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 37 + 8] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 3; ++r)
            reference_values[39 * 9 * ip + 9 * 38 + 8] += coefficients2[0][r] * basisvalues1[r];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * 39 * num_derivatives * 9, 0.0);
    if (order > 2)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[2][3][3] =
        { { { 0.0, 0.0, 0.0 },
            { 4.8989794855663495, 0.0, 0.0 },
            { 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0 },
            { 2.449489742783182, 0.0, 0.0 },
            { 4.242640687119285, 0.0, 0.0 } } };
    alignas(32) static const double dmats12[2][6][6] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
            { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
            { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
            { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][3] = { { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients1[1][3] = { { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 } };
    static const double coefficients2[1][3] = { { 0.4714045207910316, 0.0, 0.3333333333333333 } };
    static const double coefficients12[1][6] = { { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 } };
    static const double coefficients13[1][6] = { { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 } };
    static const double coefficients14[1][6] = { { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 } };
    static const double coefficients15[1][6] = { { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 } };
    static const double coefficients16[1][6] = { { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 } };
    static const double coefficients17[1][6] = { { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 } };
    const std::size_t reference_offset[39] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8 };
    const std::size_t num_components[39] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[2] = { 2.0 * X[ip * 2] - 1.0, 2.0 * X[ip * 2 + 1] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[3] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = (0.5 + 1.5 * Y[1]) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.5);
        basisvalues1[2] *= std::sqrt(1.0);
        basisvalues1[1] *= std::sqrt(3.0);
        double basisvalues2[6] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = (1.0 - Y[1]) / 2.0;
        const double tmp3_2 = tmp2_2 * tmp2_2;
        basisvalues2[3] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp3_2 * basisvalues2[0];
        basisvalues2[2] = (0.5 + 1.5 * Y[1]) * basisvalues2[0];
        basisvalues2[4] = (1.5 + 2.5 * Y[1]) * basisvalues2[1];
        basisvalues2[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues2[2] - 0.5555555555555556 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.5);
        basisvalues2[2] *= std::sqrt(1.0);
        basisvalues2[5] *= std::sqrt(1.5);
        basisvalues2[1] *= std::sqrt(3.0);
        basisvalues2[4] *= std::sqrt(4.5);
        basisvalues2[3] *= std::sqrt(7.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 39; ++i)
        {
            double derivatives[4] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            case 15:
                // Compute reference derivatives for dof 15.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients15[0][s] * aux[s];
                }
                break;
            case 16:
                // Compute reference derivatives for dof 16.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients16[0][s] * aux[s];
                }
                break;
            case 17:
                // Compute reference derivatives for dof 17.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients17[0][s] * aux[s];
                }
                break;
            case 18:
                // Compute reference derivatives for dof 18.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 19:
                // Compute reference derivatives for dof 19.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 20:
                // Compute reference derivatives for dof 20.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            case 21:
                // Compute reference derivatives for dof 21.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients15[0][s] * aux[s];
                }
                break;
            case 22:
                // Compute reference derivatives for dof 22.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients16[0][s] * aux[s];
                }
                break;
            case 23:
                // Compute reference derivatives for dof 23.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients17[0][s] * aux[s];
                }
                break;
            case 24:
                // Compute reference derivatives for dof 24.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 25:
                // Compute reference derivatives for dof 25.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 26:
                // Compute reference derivatives for dof 26.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            case 27:
                // Compute reference derivatives for dof 27.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients15[0][s] * aux[s];
                }
                break;
            case 28:
                // Compute reference derivatives for dof 28.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients16[0][s] * aux[s];
                }
                break;
            case 29:
                // Compute reference derivatives for dof 29.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients17[0][s] * aux[s];
                }
                break;
            case 30:
                // Compute reference derivatives for dof 30.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients12[0][s] * aux[s];
                }
                break;
            case 31:
                // Compute reference derivatives for dof 31.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients13[0][s] * aux[s];
                }
                break;
            case 32:
                // Compute reference derivatives for dof 32.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients14[0][s] * aux[s];
                }
                break;
            case 33:
                // Compute reference derivatives for dof 33.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients15[0][s] * aux[s];
                }
                break;
            case 34:
                // Compute reference derivatives for dof 34.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients16[0][s] * aux[s];
                }
                break;
            case 35:
                // Compute reference derivatives for dof 35.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[6] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[6][6] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats12[comb][0][0], 36, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[6][6];
                        std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 36, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats12[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 6; ++s)
                        for (std::size_t t = 0; t < 6; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 6; ++s)
                        derivatives[r] += coefficients17[0][s] * aux[s];
                }
                break;
            case 36:
                // Compute reference derivatives for dof 36.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 37:
                // Compute reference derivatives for dof 37.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 38:
                // Compute reference derivatives for dof 38.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[3] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[3][3] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 9, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[3][3];
                        std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 9, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 3; ++s)
                        for (std::size_t t = 0; t < 3; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 3; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[39 * (num_derivatives * 9) * ip + num_derivatives * 9 * i + 9 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    const std::size_t num_derivatives = std::pow(2, order);
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    std::fill_n(values, num_points * 39 * num_derivatives * 9, 0.0);
    const std::size_t reference_offsets[39] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8 };
    const std::size_t physical_offsets[39] = { 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[4][4];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[2 * 2 * ip + 2 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 39; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[39 * (num_derivatives * 9) * ip + num_derivatives * 9 * d + 9 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[39 * (num_derivatives * 9) * ip + num_derivatives * 9 * d + 9 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
        const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
        // Get coordinates and map to the reference (FIAT) element
        double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 2; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[351];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[351];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 9; ++k)
        values[k] = physical_values[9 * i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Helper variable to hold values of a single dof.
    double dof_values[9] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 39; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 9; ++s)
            values[r * 9 + s] = dof_values[s];
    }
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, 9 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[2] + coordinate_dofs[4];
    const double C1 = coordinate_dofs[3] + coordinate_dofs[5];
    // Get coordinates and map to the reference (FIAT) element
    double Y[2] = { (J[1] * (C1 - 2.0 * x[1]) + J[3] * (2.0 * x[0] - C0)) / detJ, (J[0] * (2.0 * x[1] - C1) + J[2] * (C0 - 2.0 * x[0])) / detJ };
    // Precomputed combinations
    const std::size_t combinations[2][4][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 0, 0 },
            { 1, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 1, 0 },
            { 1, 1 } } };
    // Declare transformation matrix
    double transform[4][4] =
        { { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[2 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 15:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 16:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 17:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 18:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 19:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 20:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 21:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 22:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 23:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 24:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 25:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 26:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 27:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 28:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 29:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 30:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, -0.1732050807568877, -0.09999999999999999, 0.12171612389003691, 0.09428090415820636, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 31:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.17320508075688776, -0.10000000000000003, 0.12171612389003691, -0.09428090415820635, 0.05443310539518176 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 32:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.0, 0.0, 0.2, 0.0, 0.0, 0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 33:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910316, 0.2309401076758503, 0.1333333333333333, 0.0, 0.18856180831641264, -0.1632993161855452 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 34:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.47140452079103146, -0.2309401076758503, 0.1333333333333333, 0.0, -0.18856180831641264, -0.16329931618554522 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 35:
        {
            double basisvalues[6] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = (1.0 - Y[1]) / 2.0;
            const double tmp3_2 = tmp2_2 * tmp2_2;
            basisvalues[3] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp3_2 * basisvalues[0];
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[4] = (1.5 + 2.5 * Y[1]) * basisvalues[1];
            basisvalues[5] = (0.1111111111111111 + 1.6666666666666667 * Y[1]) * basisvalues[2] - 0.5555555555555556 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[5] *= std::sqrt(1.5);
            basisvalues[1] *= std::sqrt(3.0);
            basisvalues[4] *= std::sqrt(4.5);
            basisvalues[3] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[6] = { 0.4714045207910317, 0.0, -0.2666666666666666, -0.24343224778007383, 0.0, 0.05443310539518173 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.898979485566348, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 9.486832980505149, 0.0, 0.0, 0.0, 0.0 },
                  { 3.999999999999994, 0.0, 7.071067811865468, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[6][6] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.449489742783181, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.242640687119284, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.581988897471618, 4.7434164902525735, -0.912870929175279, 0.0, 0.0, 0.0 },
                  { 1.9999999999999098, 6.123724356957937, 3.5355339059327333, 0.0, 0.0, 0.0 },
                  { -2.3094010767584896, 0.0, 8.164965809277266, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[6][6] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 36, 0.0);
                for (std::size_t t = 0; t < 6; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 36, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 36, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 6; ++t)
                            for (std::size_t u = 0; u < 6; ++u)
                                for (std::size_t tu = 0; tu < 6; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 6; ++s)
                    for (std::size_t t = 0; t < 6; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 36:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, -0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 37:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910317, 0.2886751345948129, -0.16666666666666666 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 38:
        {
            double basisvalues[3] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = (1.0 + 2.0 * Y[0] + Y[1]) / 2.0;
            basisvalues[1] = tmp1_1;
            basisvalues[2] = (0.5 + 1.5 * Y[1]) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.5);
            basisvalues[2] *= std::sqrt(1.0);
            basisvalues[1] *= std::sqrt(3.0);
            // Table(s) of coefficients
            static const double coefficients0[3] = { 0.4714045207910316, 0.0, 0.3333333333333333 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 4.8989794855663495, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0 } };
            static const double dmats1[3][3] =
                { { 0.0, 0.0, 0.0 },
                  { 2.449489742783182, 0.0, 0.0 },
                  { 4.242640687119285, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[4] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[3][3] =
                { { 1.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 9, 0.0);
                for (std::size_t t = 0; t < 3; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 9, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 9, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 3; ++t)
                            for (std::size_t u = 0; u < 3; ++u)
                                for (std::size_t tu = 0; tu < 3; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 3; ++s)
                    for (std::size_t t = 0; t < 3; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(2, n);
    // Set values equal to zero.
    std::fill_n(values, 9 * num_derivatives * 39, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[36] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 39; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 9 * num_derivatives; ++s)
            values[9 * num_derivatives * r + s] = dof_values[s];
    }
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[9];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 9:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 12:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 13:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 14:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 15:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 16:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 17:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 18:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 19:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 20:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 21:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 22:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 23:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 24:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 25:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 26:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 27:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 28:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 29:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 30:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 31:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 32:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 33:
        {
            y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 34:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 35:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 36:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 37:
        {
            y[0] = coordinate_dofs[2];
            y[1] = coordinate_dofs[3];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 38:
        {
            y[0] = coordinate_dofs[4];
            y[1] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[9];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[3] = vals[1];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[6] = vals[2];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[7] = vals[2];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[9] = vals[3];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[10] = vals[3];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[11] = vals[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[12] = vals[4];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[13] = vals[4];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[14] = vals[4];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[15] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[16] = vals[4];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[17] = vals[4];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[18] = vals[5];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[19] = vals[5];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[20] = vals[5];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[21] = vals[5];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[22] = vals[5];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[23] = vals[5];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[24] = vals[6];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[25] = vals[6];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[26] = vals[6];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[27] = vals[6];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[28] = vals[6];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[29] = vals[6];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[30] = vals[7];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[31] = vals[7];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[32] = vals[7];
    y[0] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[33] = vals[7];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[34] = vals[7];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[35] = vals[7];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    f.evaluate(vals, y, c);
    values[36] = vals[8];
    y[0] = coordinate_dofs[2];
    y[1] = coordinate_dofs[3];
    f.evaluate(vals, y, c);
    values[37] = vals[8];
    y[0] = coordinate_dofs[4];
    y[1] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[38] = vals[8];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[9] = dof_values[1];
    vertex_values[18] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[3];
    vertex_values[10] = dof_values[4];
    vertex_values[19] = dof_values[5];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[6];
    vertex_values[11] = dof_values[7];
    vertex_values[20] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[9];
    vertex_values[12] = dof_values[10];
    vertex_values[21] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[12];
    vertex_values[13] = dof_values[13];
    vertex_values[22] = dof_values[14];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[18];
    vertex_values[14] = dof_values[19];
    vertex_values[23] = dof_values[20];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[24];
    vertex_values[15] = dof_values[25];
    vertex_values[24] = dof_values[26];
    // Evaluate function and change variables
    vertex_values[7] = dof_values[30];
    vertex_values[16] = dof_values[31];
    vertex_values[25] = dof_values[32];
    // Evaluate function and change variables
    vertex_values[8] = dof_values[36];
    vertex_values[17] = dof_values[37];
    vertex_values[26] = dof_values[38];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[2 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 2] = coordinate_dofs[4];
    dof_coordinates[2 * 2 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 3] = coordinate_dofs[0];
    dof_coordinates[2 * 3 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 4] = coordinate_dofs[2];
    dof_coordinates[2 * 4 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 5] = coordinate_dofs[4];
    dof_coordinates[2 * 5 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 6] = coordinate_dofs[0];
    dof_coordinates[2 * 6 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 7] = coordinate_dofs[2];
    dof_coordinates[2 * 7 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 8] = coordinate_dofs[4];
    dof_coordinates[2 * 8 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 9] = coordinate_dofs[0];
    dof_coordinates[2 * 9 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 10] = coordinate_dofs[2];
    dof_coordinates[2 * 10 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 11] = coordinate_dofs[4];
    dof_coordinates[2 * 11 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 12] = coordinate_dofs[0];
    dof_coordinates[2 * 12 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 13] = coordinate_dofs[2];
    dof_coordinates[2 * 13 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 14] = coordinate_dofs[4];
    dof_coordinates[2 * 14 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 15] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 15 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 16] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 16 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 17] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 17 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 18] = coordinate_dofs[0];
    dof_coordinates[2 * 18 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 19] = coordinate_dofs[2];
    dof_coordinates[2 * 19 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 20] = coordinate_dofs[4];
    dof_coordinates[2 * 20 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 21] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 21 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 22] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 22 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 23] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 23 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 24] = coordinate_dofs[0];
    dof_coordinates[2 * 24 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 25] = coordinate_dofs[2];
    dof_coordinates[2 * 25 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 26] = coordinate_dofs[4];
    dof_coordinates[2 * 26 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 27] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 27 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 28] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 28 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 29] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 29 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 30] = coordinate_dofs[0];
    dof_coordinates[2 * 30 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 31] = coordinate_dofs[2];
    dof_coordinates[2 * 31 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 32] = coordinate_dofs[4];
    dof_coordinates[2 * 32 + 1] = coordinate_dofs[5];
    dof_coordinates[2 * 33] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 33 + 1] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 34] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[4];
    dof_coordinates[2 * 34 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[5];
    dof_coordinates[2 * 35] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[2];
    dof_coordinates[2 * 35 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[3];
    dof_coordinates[2 * 36] = coordinate_dofs[0];
    dof_coordinates[2 * 36 + 1] = coordinate_dofs[1];
    dof_coordinates[2 * 37] = coordinate_dofs[2];
    dof_coordinates[2 * 37 + 1] = coordinate_dofs[3];
    dof_coordinates[2 * 38] = coordinate_dofs[4];
    dof_coordinates[2 * 38 + 1] = coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[78] = { 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 78, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 4;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_5();
    case 1:
        return new dual2d_finite_element_3();
    case 2:
        return new dual2d_finite_element_3();
    case 3:
        return new dual2d_finite_element_0();
    default:
        return nullptr;
    }
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_6();
  }

};


class dual2d_finite_element_7: public ufc::finite_element
{
public:

  dual2d_finite_element_7() : ufc::finite_element()
  {
    // Do nothing
  }

  ~dual2d_finite_element_7() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FiniteElement('Real', triangle, 0)";
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t space_dimension() const final override
  {
    return 1;
  }

  std::size_t value_rank() const final override
  {
    return 0;
  }

  std::size_t value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t value_size() const final override
  {
    return 1;
  }

  std::size_t reference_value_rank() const final override
  {
    return 0;
  }

  std::size_t reference_value_dimension(std::size_t i) const final override
  {
    return 1;
  }

  std::size_t reference_value_size() const final override
  {
    return 1;
  }

  std::size_t degree() const final override
  {
    return 0;
  }

  const char * family() const final override
  {
    return "Real";
  }

  void evaluate_reference_basis(double * reference_values,
                                std::size_t num_points,
                                const double * X) const final override
  {
    static const double coefficients0[1][1] = { { 1.0 } };
    for (std::size_t k = 0; k < num_points; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basisvalues for each relevant embedded degree
        double basisvalues0[1] = {};
        basisvalues0[0] = 1.0;
        // Accumulate products of coefficients and basisvalues
        reference_values[ip] += coefficients0[0][0] * basisvalues0[0];
    }
  }

  void evaluate_reference_basis_derivatives(double * reference_values,
                                            std::size_t order,
                                            std::size_t num_points,
                                            const double * X) const final override
  {
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(2, order);
    std::fill_n(reference_values, num_points * num_derivatives, 0.0);
    if (order > 0)
        return;
  }

  void transform_reference_basis_derivatives(double * values,
                                             std::size_t order,
                                             std::size_t num_points,
                                             const double * reference_values,
                                             const double * X,
                                             const double * J,
                                             const double * detJ,
                                             const double * K,
                                             int cell_orientation) const final override
  {
    std::fill_n(values, num_points, 0.0);
    const std::size_t reference_offsets[1] = {};
    const std::size_t physical_offsets[1] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[1][1];
        for (std::size_t r = 0; r < 1; ++r)
            for (std::size_t s = 0; s < 1; ++s)
                transform[r][s] = 1.0;
        for (std::size_t d = 0; d < 1; ++d)
        {
            for (std::size_t s = 0; s < 1; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[ip + d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < 1; ++r)
                        values[ip + d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
  }

  void evaluate_basis(std::size_t i,
                      double * values,
                      const double * x,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    double X[2] = {};
    double J[4];
    double detJ;
    double K[4];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_triangle_2d(J, coordinate_dofs);
        compute_jacobian_inverse_triangle_2d(K, detJ, J);
    }
    // Evaluate basis on reference element
    double ref_values[1];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[1];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
  }

  void evaluate_basis_all(double * values,
                          const double * x,
                          const double * coordinate_dofs,
                          int cell_orientation,
                          const ufc::coordinate_mapping * cm=nullptr
                          ) const final override
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, x, coordinate_dofs, cell_orientation);
  }

  void evaluate_basis_derivatives(std::size_t i,
                                  std::size_t n,
                                  double * values,
                                  const double * x,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::coordinate_mapping * cm=nullptr
                                  ) const final override
  {
    std::size_t num_derivatives = std::pow(2, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
  }

  void evaluate_basis_derivatives_all(std::size_t n,
                                      double * values,
                                      const double * x,
                                      const double * coordinate_dofs,
                                      int cell_orientation,
                                      const ufc::coordinate_mapping * cm=nullptr
                                      ) const final override
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, x, coordinate_dofs, cell_orientation);
  }

  double evaluate_dof(std::size_t i,
                      const ufc::function& f,
                      const double * coordinate_dofs,
                      int cell_orientation,
                      const ufc::cell& c,
                      const ufc::coordinate_mapping * cm=nullptr
                      ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
            y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
  }

  void evaluate_dofs(double * values,
                             const ufc::function& f,
                             const double * coordinate_dofs,
                             int cell_orientation,
                             const ufc::cell& c,
                             const ufc::coordinate_mapping * cm=nullptr
                             ) const final override
  {
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    y[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  void interpolate_vertex_values(double * vertex_values,
                                 const double * dof_values,
                                 const double * coordinate_dofs,
                                 int cell_orientation,
                                 const ufc::coordinate_mapping * cm=nullptr
                                 ) const final override
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  void tabulate_dof_coordinates(double * dof_coordinates,
                                const double * coordinate_dofs,
                                const ufc::coordinate_mapping * cm=nullptr
                                ) const final override
  {
    dof_coordinates[0] = 0.3333333333333334 * coordinate_dofs[0] + 0.3333333333333333 * coordinate_dofs[2] + 0.3333333333333333 * coordinate_dofs[4];
    dof_coordinates[1] = 0.3333333333333334 * coordinate_dofs[1] + 0.3333333333333333 * coordinate_dofs[3] + 0.3333333333333333 * coordinate_dofs[5];
  }

  void tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const final override
  {
    static const double dof_X[2] = { 0.3333333333333333, 0.3333333333333333 };
    std::copy_n(dof_X, 2, reference_dof_coordinates);
  }

  std::size_t num_sub_elements() const final override
  {
    return 0;
  }

  ufc::finite_element * create_sub_element(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::finite_element * create() const final override
  {
    return new dual2d_finite_element_7();
  }

};


class dual2d_dofmap_0: public ufc::dofmap
{
public:

  dual2d_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 1)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 3;
  }

  std::size_t num_element_dofs() const final override
  {
    return 3;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 2;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 1, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 1, 2, 3 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_0();
  }

};


class dual2d_dofmap_1: public ufc::dofmap
{
public:

  dual2d_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 2 * num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 6;
  }

  std::size_t num_element_dofs() const final override
  {
    return 6;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 4;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 2, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 2, 4, 6 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 2;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_0();
    case 1:
        return new dual2d_dofmap_0();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_1();
  }

};


class dual2d_dofmap_2: public ufc::dofmap
{
public:

  dual2d_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_2() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Lagrange', triangle, 2)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, true, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return num_global_entities[0] + num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 6;
  }

  std::size_t num_element_dofs() const final override
  {
    return 6;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 3;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 1, 1, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 1, 3, 6 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[1][0];
    dofs[4] = offset + entity_indices[1][1];
    dofs[5] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 4;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 5;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 3;
            break;
        case 1:
            dofs[0] = 4;
            break;
        case 2:
            dofs[0] = 5;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 5;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_2();
  }

};


class dual2d_dofmap_3: public ufc::dofmap
{
public:

  dual2d_dofmap_3() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_3() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, true, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 2 * num_global_entities[0] + 2 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 12;
  }

  std::size_t num_element_dofs() const final override
  {
    return 12;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 6;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 2, 2, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 2, 6, 12 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[1][0];
    dofs[4] = offset + entity_indices[1][1];
    dofs[5] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[6] = offset + entity_indices[0][0];
    dofs[7] = offset + entity_indices[0][1];
    dofs[8] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + entity_indices[1][0];
    dofs[10] = offset + entity_indices[1][1];
    dofs[11] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 7;
        dofs[4] = 8;
        dofs[5] = 9;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 6;
        dofs[4] = 8;
        dofs[5] = 10;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 5;
        dofs[3] = 6;
        dofs[4] = 7;
        dofs[5] = 11;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 6;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 7;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 8;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 3;
            dofs[1] = 9;
            break;
        case 1:
            dofs[0] = 4;
            dofs[1] = 10;
            break;
        case 2:
            dofs[0] = 5;
            dofs[1] = 11;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 6;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 7;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 8;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 7;
            dofs[4] = 8;
            dofs[5] = 9;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 10;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 5;
            dofs[3] = 6;
            dofs[4] = 7;
            dofs[5] = 11;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 2;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_2();
    case 1:
        return new dual2d_dofmap_2();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_3();
  }

};


class dual2d_dofmap_4: public ufc::dofmap
{
public:

  dual2d_dofmap_4() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_4() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for MixedElement(VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2), FiniteElement('Lagrange', triangle, 1), FiniteElement('Lagrange', triangle, 1))";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, true, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 4 * num_global_entities[0] + 2 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 18;
  }

  std::size_t num_element_dofs() const final override
  {
    return 18;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 10;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 4, 2, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 4, 10, 18 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[1][0];
    dofs[4] = offset + entity_indices[1][1];
    dofs[5] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[6] = offset + entity_indices[0][0];
    dofs[7] = offset + entity_indices[0][1];
    dofs[8] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + entity_indices[1][0];
    dofs[10] = offset + entity_indices[1][1];
    dofs[11] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[12] = offset + entity_indices[0][0];
    dofs[13] = offset + entity_indices[0][1];
    dofs[14] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[15] = offset + entity_indices[0][0];
    dofs[16] = offset + entity_indices[0][1];
    dofs[17] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 7;
        dofs[4] = 8;
        dofs[5] = 9;
        dofs[6] = 13;
        dofs[7] = 14;
        dofs[8] = 16;
        dofs[9] = 17;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 6;
        dofs[4] = 8;
        dofs[5] = 10;
        dofs[6] = 12;
        dofs[7] = 14;
        dofs[8] = 15;
        dofs[9] = 17;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 5;
        dofs[3] = 6;
        dofs[4] = 7;
        dofs[5] = 11;
        dofs[6] = 12;
        dofs[7] = 13;
        dofs[8] = 15;
        dofs[9] = 16;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 6;
            dofs[2] = 12;
            dofs[3] = 15;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 7;
            dofs[2] = 13;
            dofs[3] = 16;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 8;
            dofs[2] = 14;
            dofs[3] = 17;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 3;
            dofs[1] = 9;
            break;
        case 1:
            dofs[0] = 4;
            dofs[1] = 10;
            break;
        case 2:
            dofs[0] = 5;
            dofs[1] = 11;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 6;
            dofs[2] = 12;
            dofs[3] = 15;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 7;
            dofs[2] = 13;
            dofs[3] = 16;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 8;
            dofs[2] = 14;
            dofs[3] = 17;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 7;
            dofs[4] = 8;
            dofs[5] = 9;
            dofs[6] = 13;
            dofs[7] = 14;
            dofs[8] = 16;
            dofs[9] = 17;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 10;
            dofs[6] = 12;
            dofs[7] = 14;
            dofs[8] = 15;
            dofs[9] = 17;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 5;
            dofs[3] = 6;
            dofs[4] = 7;
            dofs[5] = 11;
            dofs[6] = 12;
            dofs[7] = 13;
            dofs[8] = 15;
            dofs[9] = 16;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 3;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_3();
    case 1:
        return new dual2d_dofmap_0();
    case 2:
        return new dual2d_dofmap_0();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_4();
  }

};


class dual2d_dofmap_5: public ufc::dofmap
{
public:

  dual2d_dofmap_5() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_5() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for TensorElement(FiniteElement('Lagrange', triangle, 1), shape=(2, 2), symmetry={})";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, false, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 4 * num_global_entities[0];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 12;
  }

  std::size_t num_element_dofs() const final override
  {
    return 12;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 8;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 4, 0, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 4, 8, 12 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[6] = offset + entity_indices[0][0];
    dofs[7] = offset + entity_indices[0][1];
    dofs[8] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + entity_indices[0][0];
    dofs[10] = offset + entity_indices[0][1];
    dofs[11] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        dofs[4] = 7;
        dofs[5] = 8;
        dofs[6] = 10;
        dofs[7] = 11;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 8;
        dofs[6] = 9;
        dofs[7] = 11;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 7;
            dofs[5] = 8;
            dofs[6] = 10;
            dofs[7] = 11;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 8;
            dofs[6] = 9;
            dofs[7] = 11;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 4;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_0();
    case 1:
        return new dual2d_dofmap_0();
    case 2:
        return new dual2d_dofmap_0();
    case 3:
        return new dual2d_dofmap_0();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_5();
  }

};


class dual2d_dofmap_6: public ufc::dofmap
{
public:

  dual2d_dofmap_6() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_6() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for MixedElement(TensorElement(FiniteElement('Lagrange', triangle, 1), shape=(2, 2), symmetry={}), VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2), VectorElement(FiniteElement('Lagrange', triangle, 2), dim=2), FiniteElement('Lagrange', triangle, 1))";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = { true, true, false };
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 9 * num_global_entities[0] + 4 * num_global_entities[1];
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 39;
  }

  std::size_t num_element_dofs() const final override
  {
    return 39;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 22;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 9, 4, 0 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 9, 22, 39 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + entity_indices[0][0];
    dofs[4] = offset + entity_indices[0][1];
    dofs[5] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[6] = offset + entity_indices[0][0];
    dofs[7] = offset + entity_indices[0][1];
    dofs[8] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + entity_indices[0][0];
    dofs[10] = offset + entity_indices[0][1];
    dofs[11] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[12] = offset + entity_indices[0][0];
    dofs[13] = offset + entity_indices[0][1];
    dofs[14] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[15] = offset + entity_indices[1][0];
    dofs[16] = offset + entity_indices[1][1];
    dofs[17] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[18] = offset + entity_indices[0][0];
    dofs[19] = offset + entity_indices[0][1];
    dofs[20] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[21] = offset + entity_indices[1][0];
    dofs[22] = offset + entity_indices[1][1];
    dofs[23] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[24] = offset + entity_indices[0][0];
    dofs[25] = offset + entity_indices[0][1];
    dofs[26] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[27] = offset + entity_indices[1][0];
    dofs[28] = offset + entity_indices[1][1];
    dofs[29] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[30] = offset + entity_indices[0][0];
    dofs[31] = offset + entity_indices[0][1];
    dofs[32] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[33] = offset + entity_indices[1][0];
    dofs[34] = offset + entity_indices[1][1];
    dofs[35] = offset + entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[36] = offset + entity_indices[0][0];
    dofs[37] = offset + entity_indices[0][1];
    dofs[38] = offset + entity_indices[0][2];
    offset += num_global_entities[0];
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 4;
        dofs[3] = 5;
        dofs[4] = 7;
        dofs[5] = 8;
        dofs[6] = 10;
        dofs[7] = 11;
        dofs[8] = 13;
        dofs[9] = 14;
        dofs[10] = 15;
        dofs[11] = 19;
        dofs[12] = 20;
        dofs[13] = 21;
        dofs[14] = 25;
        dofs[15] = 26;
        dofs[16] = 27;
        dofs[17] = 31;
        dofs[18] = 32;
        dofs[19] = 33;
        dofs[20] = 37;
        dofs[21] = 38;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 8;
        dofs[6] = 9;
        dofs[7] = 11;
        dofs[8] = 12;
        dofs[9] = 14;
        dofs[10] = 16;
        dofs[11] = 18;
        dofs[12] = 20;
        dofs[13] = 22;
        dofs[14] = 24;
        dofs[15] = 26;
        dofs[16] = 28;
        dofs[17] = 30;
        dofs[18] = 32;
        dofs[19] = 34;
        dofs[20] = 36;
        dofs[21] = 38;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        dofs[8] = 12;
        dofs[9] = 13;
        dofs[10] = 17;
        dofs[11] = 18;
        dofs[12] = 19;
        dofs[13] = 23;
        dofs[14] = 24;
        dofs[15] = 25;
        dofs[16] = 29;
        dofs[17] = 30;
        dofs[18] = 31;
        dofs[19] = 35;
        dofs[20] = 36;
        dofs[21] = 37;
        break;
    }
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            dofs[4] = 12;
            dofs[5] = 18;
            dofs[6] = 24;
            dofs[7] = 30;
            dofs[8] = 36;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 19;
            dofs[6] = 25;
            dofs[7] = 31;
            dofs[8] = 37;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            dofs[4] = 14;
            dofs[5] = 20;
            dofs[6] = 26;
            dofs[7] = 32;
            dofs[8] = 38;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 15;
            dofs[1] = 21;
            dofs[2] = 27;
            dofs[3] = 33;
            break;
        case 1:
            dofs[0] = 16;
            dofs[1] = 22;
            dofs[2] = 28;
            dofs[3] = 34;
            break;
        case 2:
            dofs[0] = 17;
            dofs[1] = 23;
            dofs[2] = 29;
            dofs[3] = 35;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 9;
            dofs[4] = 12;
            dofs[5] = 18;
            dofs[6] = 24;
            dofs[7] = 30;
            dofs[8] = 36;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 4;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 19;
            dofs[6] = 25;
            dofs[7] = 31;
            dofs[8] = 37;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 5;
            dofs[2] = 8;
            dofs[3] = 11;
            dofs[4] = 14;
            dofs[5] = 20;
            dofs[6] = 26;
            dofs[7] = 32;
            dofs[8] = 38;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 7;
            dofs[5] = 8;
            dofs[6] = 10;
            dofs[7] = 11;
            dofs[8] = 13;
            dofs[9] = 14;
            dofs[10] = 15;
            dofs[11] = 19;
            dofs[12] = 20;
            dofs[13] = 21;
            dofs[14] = 25;
            dofs[15] = 26;
            dofs[16] = 27;
            dofs[17] = 31;
            dofs[18] = 32;
            dofs[19] = 33;
            dofs[20] = 37;
            dofs[21] = 38;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 8;
            dofs[6] = 9;
            dofs[7] = 11;
            dofs[8] = 12;
            dofs[9] = 14;
            dofs[10] = 16;
            dofs[11] = 18;
            dofs[12] = 20;
            dofs[13] = 22;
            dofs[14] = 24;
            dofs[15] = 26;
            dofs[16] = 28;
            dofs[17] = 30;
            dofs[18] = 32;
            dofs[19] = 34;
            dofs[20] = 36;
            dofs[21] = 38;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            dofs[8] = 12;
            dofs[9] = 13;
            dofs[10] = 17;
            dofs[11] = 18;
            dofs[12] = 19;
            dofs[13] = 23;
            dofs[14] = 24;
            dofs[15] = 25;
            dofs[16] = 29;
            dofs[17] = 30;
            dofs[18] = 31;
            dofs[19] = 35;
            dofs[20] = 36;
            dofs[21] = 37;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 4;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_5();
    case 1:
        return new dual2d_dofmap_3();
    case 2:
        return new dual2d_dofmap_3();
    case 3:
        return new dual2d_dofmap_0();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_6();
  }

};


class dual2d_dofmap_7: public ufc::dofmap
{
public:

  dual2d_dofmap_7() : ufc::dofmap()
  {
    // Do nothing
  }

  ~dual2d_dofmap_7() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC dofmap for FiniteElement('Real', triangle, 0)";
  }

  bool needs_mesh_entities(std::size_t d) const final override
  {
    static const bool return_values[3] = {};
    if (d >= 3)
        return false;
    return return_values[d];
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  std::size_t global_dimension(const std::vector<std::size_t>&
                               num_global_entities) const final override
  {
    return 1;
  }

  std::size_t num_global_support_dofs() const final override
  {
    return 1;
  }

  std::size_t num_element_support_dofs() const final override
  {
    return 0;
  }

  std::size_t num_element_dofs() const final override
  {
    return 1;
  }

  std::size_t num_facet_dofs() const final override
  {
    return 0;
  }

  std::size_t num_entity_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  std::size_t num_entity_closure_dofs(std::size_t d) const final override
  {
    static const std::size_t return_values[3] = { 0, 0, 1 };
    if (d >= 3)
        return 0;
    return return_values[d];
  }

  void tabulate_dofs(std::size_t * dofs,
                     const std::vector<std::size_t>& num_global_entities,
                     const std::vector<std::vector<std::size_t>>& entity_indices) const final override
  {
    dofs[0] = 0;
  }

  void tabulate_facet_dofs(std::size_t * dofs,
                           std::size_t facet) const final override
  {
    // Do nothing
  }

  void tabulate_entity_dofs(std::size_t * dofs,
                            std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }

  void tabulate_entity_closure_dofs(std::size_t * dofs,
                                    std::size_t d, std::size_t i) const final override
  {
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        }
        break;
    }
  }


  std::size_t num_sub_dofmaps() const final override
  {
    return 0;
  }

  ufc::dofmap * create_sub_dofmap(std::size_t i) const final override
  {
    return nullptr;
  }

  ufc::dofmap * create() const final override
  {
    return new dual2d_dofmap_7();
  }

};


class dual2d_coordinate_mapping_1: public ufc::coordinate_mapping
{
public:

  dual2d_coordinate_mapping_1() : ufc::coordinate_mapping()
  {
    // Do nothing
  }

  ~dual2d_coordinate_mapping_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2)";
  }

  ufc::coordinate_mapping * create() const final override
  {
    return new dual2d_coordinate_mapping_1();
  }

  std::size_t geometric_dimension() const final override
  {
    return 2;
  }

  std::size_t topological_dimension() const final override
  {
    return 2;
  }

  ufc::shape cell_shape() const final override
  {
    return ufc::shape::triangle;
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new dual2d_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new dual2d_dofmap_1();
  }

  void compute_physical_coordinates(
      double * x, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs) const final override
  {
    dual2d_finite_element_0 xelement;
    double phi[3];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[2 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t d = 0; d < 3; ++d)
                x[2 * ip + i] += coordinate_dofs[2 * d + i] * phi[d];
    }
  }

  void compute_reference_coordinates(
      double * X, std::size_t num_points,
      const double * x,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double J[4];
    double detJ[1];
    double K[4];
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
  }

  void compute_reference_geometry(
      double * X, double * J, double * detJ, double * K, std::size_t num_points,
      const double * x,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    const double phi_X0[3] = { 1.0, 0.0, 0.0 };
    const double dphi_X0[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    double x0[2] = {};
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t k = 0; k < 3; ++k)
            x0[i] += coordinate_dofs[2 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 2; ++i)
    {
        for (std::size_t j = 0; j < 2; ++j)
        {
            J[2 * i + j] = 0.0;
            for (std::size_t k = 0; k < 3; ++k)
                J[2 * i + j] += coordinate_dofs[2 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t i = 0; i < 2; ++i)
                X[2 * ip + j] += K[2 * j + i] * (x[2 * ip + i] - x0[i]);
  }

  void compute_jacobians(
      double * J, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs) const final override
  {
    dual2d_finite_element_0 xelement;
    double dphi[6];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[2 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 2; ++i)
            for (std::size_t j = 0; j < 2; ++j)
                for (std::size_t d = 0; d < 3; ++d)
                    J[2 * 2 * ip + 2 * i + j] += coordinate_dofs[2 * d + i] * dphi[2 * d + j];
    }
  }

  void compute_jacobian_determinants(
      double * detJ, std::size_t num_points,
      const double * J,
      int cell_orientation) const final override
  {
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[2 * 2 * ip] * J[2 * 2 * ip + 2 + 1] - J[2 * 2 * ip + 1] * J[2 * 2 * ip + 2];
  }

  void compute_jacobian_inverses(
      double * K, std::size_t num_points,
      const double * J, const double * detJ) const final override
  {
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[2 * 2 * ip] = J[2 * 2 * ip + 2 + 1] / detJ[ip];
        K[2 * 2 * ip + 1] = -J[2 * 2 * ip + 1] / detJ[ip];
        K[2 * 2 * ip + 2] = -J[2 * 2 * ip + 2] / detJ[ip];
        K[2 * 2 * ip + 2 + 1] = J[2 * 2 * ip] / detJ[ip];
    }
  }

  void compute_geometry(
      double * x, double * J, double * detJ, double * K, std::size_t num_points,
      const double * X,
      const double * coordinate_dofs, int cell_orientation) const final override
  {
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
  }

  void compute_midpoint_geometry(
      double * x, double * J,
      const double * coordinate_dofs) const final override
  {
    const double phi_Xm[3] = { 0.33333333333333337, 0.3333333333333333, 0.3333333333333333 };
    const double dphi_Xm[2][3] =
        { { -1.0, 1.0, 0.0 },
          { -1.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t d = 0; d < 3; ++d)
            x[i] += coordinate_dofs[2 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 2; ++i)
        for (std::size_t j = 0; j < 2; ++j)
            for (std::size_t d = 0; d < 3; ++d)
                J[2 * i + j] += coordinate_dofs[2 * d + i] * dphi_Xm[j][d];
  }

};


class dual2d_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  dual2d_cell_integral_0_otherwise() : ufc::cell_integral()
  {

  }

  ~dual2d_cell_integral_0_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation,
                       std::size_t local_facet) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 13
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           13
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE3_C0_D01_Q49[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double PI0[1][3][3] =
        { { { 0.08333333333333338, 0.0416666666666667, 0.04166666666666669 },
            { 0.0416666666666667, 0.0833333333333334, 0.04166666666666669 },
            { 0.04166666666666669, 0.04166666666666669, 0.08333333333333334 } } };
    alignas(32) static const double PI1[1][6][6] =
        { { { 0.01666666666666667, -0.002777777777777777, -0.002777777777777776, -0.0111111111111111, 0.0, 0.0 },
            { -0.002777777777777777, 0.01666666666666669, -0.002777777777777782, 0.0, -0.01111111111111111, 0.0 },
            { -0.002777777777777776, -0.002777777777777782, 0.01666666666666667, 0.0, 0.0, -0.01111111111111111 },
            { -0.0111111111111111, 0.0, 0.0, 0.08888888888888891, 0.04444444444444443, 0.04444444444444446 },
            { 0.0, -0.01111111111111111, 0.0, 0.04444444444444443, 0.08888888888888884, 0.04444444444444443 },
            { 0.0, 0.0, -0.01111111111111111, 0.04444444444444446, 0.04444444444444443, 0.08888888888888892 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE3_C0_D01_Q49[0][0][0] + coordinate_dofs[2] * FE3_C0_D01_Q49[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE3_C0_D01_Q49[0][0][0] + coordinate_dofs[5] * FE3_C0_D01_Q49[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE3_C0_D01_Q49[0][0][0] + coordinate_dofs[4] * FE3_C0_D01_Q49[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE3_C0_D01_Q49[0][0][0] + coordinate_dofs[3] * FE3_C0_D01_Q49[0][0][1];
    alignas(32) double sp[4];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = std::abs(sp[2]);
    A[0] = sp[3] * PI0[0][0][0];
    A[1] = sp[3] * PI0[0][0][1];
    A[2] = sp[3] * PI0[0][0][2];
    std::fill(A + 3, A + 39, 0.0);
    A[39] = sp[3] * PI0[0][1][0];
    A[40] = sp[3] * PI0[0][1][1];
    A[41] = sp[3] * PI0[0][1][2];
    std::fill(A + 42, A + 78, 0.0);
    A[78] = sp[3] * PI0[0][2][0];
    A[79] = sp[3] * PI0[0][2][1];
    A[80] = sp[3] * PI0[0][2][2];
    std::fill(A + 81, A + 120, 0.0);
    A[120] = sp[3] * PI0[0][0][0];
    A[121] = sp[3] * PI0[0][0][1];
    A[122] = sp[3] * PI0[0][0][2];
    std::fill(A + 123, A + 159, 0.0);
    A[159] = sp[3] * PI0[0][1][0];
    A[160] = sp[3] * PI0[0][1][1];
    A[161] = sp[3] * PI0[0][1][2];
    std::fill(A + 162, A + 198, 0.0);
    A[198] = sp[3] * PI0[0][2][0];
    A[199] = sp[3] * PI0[0][2][1];
    A[200] = sp[3] * PI0[0][2][2];
    std::fill(A + 201, A + 240, 0.0);
    A[240] = sp[3] * PI0[0][0][0];
    A[241] = sp[3] * PI0[0][0][1];
    A[242] = sp[3] * PI0[0][0][2];
    std::fill(A + 243, A + 279, 0.0);
    A[279] = sp[3] * PI0[0][1][0];
    A[280] = sp[3] * PI0[0][1][1];
    A[281] = sp[3] * PI0[0][1][2];
    std::fill(A + 282, A + 318, 0.0);
    A[318] = sp[3] * PI0[0][2][0];
    A[319] = sp[3] * PI0[0][2][1];
    A[320] = sp[3] * PI0[0][2][2];
    std::fill(A + 321, A + 360, 0.0);
    A[360] = sp[3] * PI0[0][0][0];
    A[361] = sp[3] * PI0[0][0][1];
    A[362] = sp[3] * PI0[0][0][2];
    std::fill(A + 363, A + 399, 0.0);
    A[399] = sp[3] * PI0[0][1][0];
    A[400] = sp[3] * PI0[0][1][1];
    A[401] = sp[3] * PI0[0][1][2];
    std::fill(A + 402, A + 438, 0.0);
    A[438] = sp[3] * PI0[0][2][0];
    A[439] = sp[3] * PI0[0][2][1];
    A[440] = sp[3] * PI0[0][2][2];
    std::fill(A + 441, A + 480, 0.0);
    A[480] = sp[3] * PI1[0][0][0];
    A[481] = sp[3] * PI1[0][0][1];
    A[482] = sp[3] * PI1[0][0][2];
    A[483] = sp[3] * PI1[0][0][3];
    A[484] = sp[3] * PI1[0][0][4];
    A[485] = sp[3] * PI1[0][0][5];
    std::fill(A + 486, A + 519, 0.0);
    A[519] = sp[3] * PI1[0][1][0];
    A[520] = sp[3] * PI1[0][1][1];
    A[521] = sp[3] * PI1[0][1][2];
    A[522] = sp[3] * PI1[0][1][3];
    A[523] = sp[3] * PI1[0][1][4];
    A[524] = sp[3] * PI1[0][1][5];
    std::fill(A + 525, A + 558, 0.0);
    A[558] = sp[3] * PI1[0][2][0];
    A[559] = sp[3] * PI1[0][2][1];
    A[560] = sp[3] * PI1[0][2][2];
    A[561] = sp[3] * PI1[0][2][3];
    A[562] = sp[3] * PI1[0][2][4];
    A[563] = sp[3] * PI1[0][2][5];
    std::fill(A + 564, A + 597, 0.0);
    A[597] = sp[3] * PI1[0][3][0];
    A[598] = sp[3] * PI1[0][3][1];
    A[599] = sp[3] * PI1[0][3][2];
    A[600] = sp[3] * PI1[0][3][3];
    A[601] = sp[3] * PI1[0][3][4];
    A[602] = sp[3] * PI1[0][3][5];
    std::fill(A + 603, A + 636, 0.0);
    A[636] = sp[3] * PI1[0][4][0];
    A[637] = sp[3] * PI1[0][4][1];
    A[638] = sp[3] * PI1[0][4][2];
    A[639] = sp[3] * PI1[0][4][3];
    A[640] = sp[3] * PI1[0][4][4];
    A[641] = sp[3] * PI1[0][4][5];
    std::fill(A + 642, A + 675, 0.0);
    A[675] = sp[3] * PI1[0][5][0];
    A[676] = sp[3] * PI1[0][5][1];
    A[677] = sp[3] * PI1[0][5][2];
    A[678] = sp[3] * PI1[0][5][3];
    A[679] = sp[3] * PI1[0][5][4];
    A[680] = sp[3] * PI1[0][5][5];
    std::fill(A + 681, A + 720, 0.0);
    A[720] = sp[3] * PI1[0][0][0];
    A[721] = sp[3] * PI1[0][0][1];
    A[722] = sp[3] * PI1[0][0][2];
    A[723] = sp[3] * PI1[0][0][3];
    A[724] = sp[3] * PI1[0][0][4];
    A[725] = sp[3] * PI1[0][0][5];
    std::fill(A + 726, A + 759, 0.0);
    A[759] = sp[3] * PI1[0][1][0];
    A[760] = sp[3] * PI1[0][1][1];
    A[761] = sp[3] * PI1[0][1][2];
    A[762] = sp[3] * PI1[0][1][3];
    A[763] = sp[3] * PI1[0][1][4];
    A[764] = sp[3] * PI1[0][1][5];
    std::fill(A + 765, A + 798, 0.0);
    A[798] = sp[3] * PI1[0][2][0];
    A[799] = sp[3] * PI1[0][2][1];
    A[800] = sp[3] * PI1[0][2][2];
    A[801] = sp[3] * PI1[0][2][3];
    A[802] = sp[3] * PI1[0][2][4];
    A[803] = sp[3] * PI1[0][2][5];
    std::fill(A + 804, A + 837, 0.0);
    A[837] = sp[3] * PI1[0][3][0];
    A[838] = sp[3] * PI1[0][3][1];
    A[839] = sp[3] * PI1[0][3][2];
    A[840] = sp[3] * PI1[0][3][3];
    A[841] = sp[3] * PI1[0][3][4];
    A[842] = sp[3] * PI1[0][3][5];
    std::fill(A + 843, A + 876, 0.0);
    A[876] = sp[3] * PI1[0][4][0];
    A[877] = sp[3] * PI1[0][4][1];
    A[878] = sp[3] * PI1[0][4][2];
    A[879] = sp[3] * PI1[0][4][3];
    A[880] = sp[3] * PI1[0][4][4];
    A[881] = sp[3] * PI1[0][4][5];
    std::fill(A + 882, A + 915, 0.0);
    A[915] = sp[3] * PI1[0][5][0];
    A[916] = sp[3] * PI1[0][5][1];
    A[917] = sp[3] * PI1[0][5][2];
    A[918] = sp[3] * PI1[0][5][3];
    A[919] = sp[3] * PI1[0][5][4];
    A[920] = sp[3] * PI1[0][5][5];
    std::fill(A + 921, A + 960, 0.0);
    A[960] = sp[3] * PI1[0][0][0];
    A[961] = sp[3] * PI1[0][0][1];
    A[962] = sp[3] * PI1[0][0][2];
    A[963] = sp[3] * PI1[0][0][3];
    A[964] = sp[3] * PI1[0][0][4];
    A[965] = sp[3] * PI1[0][0][5];
    std::fill(A + 966, A + 999, 0.0);
    A[999] = sp[3] * PI1[0][1][0];
    A[1000] = sp[3] * PI1[0][1][1];
    A[1001] = sp[3] * PI1[0][1][2];
    A[1002] = sp[3] * PI1[0][1][3];
    A[1003] = sp[3] * PI1[0][1][4];
    A[1004] = sp[3] * PI1[0][1][5];
    std::fill(A + 1005, A + 1038, 0.0);
    A[1038] = sp[3] * PI1[0][2][0];
    A[1039] = sp[3] * PI1[0][2][1];
    A[1040] = sp[3] * PI1[0][2][2];
    A[1041] = sp[3] * PI1[0][2][3];
    A[1042] = sp[3] * PI1[0][2][4];
    A[1043] = sp[3] * PI1[0][2][5];
    std::fill(A + 1044, A + 1077, 0.0);
    A[1077] = sp[3] * PI1[0][3][0];
    A[1078] = sp[3] * PI1[0][3][1];
    A[1079] = sp[3] * PI1[0][3][2];
    A[1080] = sp[3] * PI1[0][3][3];
    A[1081] = sp[3] * PI1[0][3][4];
    A[1082] = sp[3] * PI1[0][3][5];
    std::fill(A + 1083, A + 1116, 0.0);
    A[1116] = sp[3] * PI1[0][4][0];
    A[1117] = sp[3] * PI1[0][4][1];
    A[1118] = sp[3] * PI1[0][4][2];
    A[1119] = sp[3] * PI1[0][4][3];
    A[1120] = sp[3] * PI1[0][4][4];
    A[1121] = sp[3] * PI1[0][4][5];
    std::fill(A + 1122, A + 1155, 0.0);
    A[1155] = sp[3] * PI1[0][5][0];
    A[1156] = sp[3] * PI1[0][5][1];
    A[1157] = sp[3] * PI1[0][5][2];
    A[1158] = sp[3] * PI1[0][5][3];
    A[1159] = sp[3] * PI1[0][5][4];
    A[1160] = sp[3] * PI1[0][5][5];
    std::fill(A + 1161, A + 1200, 0.0);
    A[1200] = sp[3] * PI1[0][0][0];
    A[1201] = sp[3] * PI1[0][0][1];
    A[1202] = sp[3] * PI1[0][0][2];
    A[1203] = sp[3] * PI1[0][0][3];
    A[1204] = sp[3] * PI1[0][0][4];
    A[1205] = sp[3] * PI1[0][0][5];
    std::fill(A + 1206, A + 1239, 0.0);
    A[1239] = sp[3] * PI1[0][1][0];
    A[1240] = sp[3] * PI1[0][1][1];
    A[1241] = sp[3] * PI1[0][1][2];
    A[1242] = sp[3] * PI1[0][1][3];
    A[1243] = sp[3] * PI1[0][1][4];
    A[1244] = sp[3] * PI1[0][1][5];
    std::fill(A + 1245, A + 1278, 0.0);
    A[1278] = sp[3] * PI1[0][2][0];
    A[1279] = sp[3] * PI1[0][2][1];
    A[1280] = sp[3] * PI1[0][2][2];
    A[1281] = sp[3] * PI1[0][2][3];
    A[1282] = sp[3] * PI1[0][2][4];
    A[1283] = sp[3] * PI1[0][2][5];
    std::fill(A + 1284, A + 1317, 0.0);
    A[1317] = sp[3] * PI1[0][3][0];
    A[1318] = sp[3] * PI1[0][3][1];
    A[1319] = sp[3] * PI1[0][3][2];
    A[1320] = sp[3] * PI1[0][3][3];
    A[1321] = sp[3] * PI1[0][3][4];
    A[1322] = sp[3] * PI1[0][3][5];
    std::fill(A + 1323, A + 1356, 0.0);
    A[1356] = sp[3] * PI1[0][4][0];
    A[1357] = sp[3] * PI1[0][4][1];
    A[1358] = sp[3] * PI1[0][4][2];
    A[1359] = sp[3] * PI1[0][4][3];
    A[1360] = sp[3] * PI1[0][4][4];
    A[1361] = sp[3] * PI1[0][4][5];
    std::fill(A + 1362, A + 1395, 0.0);
    A[1395] = sp[3] * PI1[0][5][0];
    A[1396] = sp[3] * PI1[0][5][1];
    A[1397] = sp[3] * PI1[0][5][2];
    A[1398] = sp[3] * PI1[0][5][3];
    A[1399] = sp[3] * PI1[0][5][4];
    A[1400] = sp[3] * PI1[0][5][5];
    std::fill(A + 1401, A + 1440, 0.0);
    A[1440] = sp[3] * PI0[0][0][0];
    A[1441] = sp[3] * PI0[0][0][1];
    A[1442] = sp[3] * PI0[0][0][2];
    std::fill(A + 1443, A + 1479, 0.0);
    A[1479] = sp[3] * PI0[0][1][0];
    A[1480] = sp[3] * PI0[0][1][1];
    A[1481] = sp[3] * PI0[0][1][2];
    std::fill(A + 1482, A + 1518, 0.0);
    A[1518] = sp[3] * PI0[0][2][0];
    A[1519] = sp[3] * PI0[0][2][1];
    A[1520] = sp[3] * PI0[0][2][2];
  }

};


class dual2d_cell_integral_1_otherwise: public ufc::cell_integral
{
public:

  dual2d_cell_integral_1_otherwise() : ufc::cell_integral()
  {

  }

  ~dual2d_cell_integral_1_otherwise() override
  {

  }

  const std::vector<bool> & enabled_coefficients() const final override
  {
static const std::vector<bool> enabled({true, true, true, true, true, true, true, true, true, true, true, true, true});
return enabled;
  }

  void tabulate_tensor(double * A,
                       const double * const * w,
                       const double * coordinate_dofs,
                       int cell_orientation,
                       std::size_t local_facet) const final override
  {
    // This function was generated using 'uflacs' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 13
    // quadrature_rule:   'default'
    // representation:    'uflacs'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 22
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           13
    // quadrature_rule:             'default'
    // representation:              'uflacs'
    // Quadrature rules
    alignas(32) static const double weights49[49] = { 0.003623466079725794, 0.00715464377909615, 0.008247603013529583, 0.006935542753734078, 0.004297910087982426, 0.001774485071438052, 0.0003375907567113747, 0.007827186648495099, 0.01545501766273407, 0.01781596040067579, 0.01498172921938941, 0.009284078756888543, 0.003833132573484685, 0.000729242610651565, 0.01068501060131498, 0.02109787781815244, 0.02432083637489712, 0.02045178462250981, 0.0126738360020928, 0.005232667115687635, 0.0009955000916249657, 0.01169603676441937, 0.02309417967090931, 0.02662209772138336, 0.02238695250460707, 0.01387304677156393, 0.005727787200652747, 0.001089695284831587, 0.01068501060131498, 0.02109787781815245, 0.02432083637489713, 0.02045178462250982, 0.0126738360020928, 0.005232667115687637, 0.0009955000916249662, 0.007827186648495099, 0.01545501766273407, 0.01781596040067579, 0.01498172921938941, 0.009284078756888543, 0.003833132573484685, 0.000729242610651565, 0.003623466079725802, 0.007154643779096167, 0.008247603013529604, 0.006935542753734095, 0.004297910087982437, 0.001774485071438057, 0.0003375907567113755 };
    // Precomputed values of basis functions and precomputations
    // FE* dimensions: [entities][points][dofs]
    // PI* dimensions: [entities][dofs][dofs] or [entities][dofs]
    // PM* dimensions: [entities][dofs][dofs]
    alignas(32) static const double FE16_C0_D01_Q49[1][49][5] =
        { { { -2.810586324740912, -0.9100824542451502, 0.09949612950423231, 3.720668778986065, -0.09949612950424026 },
            { -2.451172124893734, -0.5412837873563827, 0.09011166246264335, 2.99245591225012, -0.09011166246265255 },
            { -1.862109731466276, 0.06315929113835896, 0.07473097739536029, 1.798950440327921, -0.07473097739537006 },
            { -1.132922924695843, 0.8113854946777803, 0.05569158062637229, 0.3215374300180672, -0.05569158062638371 },
            { -0.3746072524258175, 1.589501131547323, 0.03589161602685307, -1.2148938791215, -0.03589161602686611 },
            { 0.2973828832189765, 2.279037233052433, 0.01834565016653565, -2.576420116271403, -0.01834565016655054 },
            { 0.7806763961776377, 2.774949757852314, 0.005726638325313418, -3.555626154029944, -0.005726638325329759 },
            { -2.404765266166478, -0.9100824542451501, 0.5053171880786661, 3.314847720411632, -0.5053171880786754 },
            { -2.083628076369342, -0.5412837873563827, 0.4576557109870347, 2.624911863725729, -0.4576557109870443 },
            { -1.557299840810196, 0.06315929113835927, 0.3795408680514404, 1.494140549671841, -0.3795408680514511 },
            { -0.9057702071369256, 0.8113854946777804, 0.2828442981852892, 0.09438471245915019, -0.282844298185301 },
            { -0.2282138833315043, 1.589501131547323, 0.1822849851211657, -1.361287248215813, -0.1822849851211792 },
            { 0.3722104288523841, 2.279037233052433, 0.09317319579994297, -2.65124766190481, -0.09317319579995809 },
            { 0.8040339924865469, 2.774949757852314, 0.02908423463422307, -3.578983750338853, -0.02908423463423908 },
            { -1.748485229893193, -0.91008245424515, 1.16159722435195, 2.658567684138348, -1.161597224351961 },
            { -1.489248321053183, -0.5412837873563824, 1.052035466303193, 2.03053210840957, -1.052035466303204 },
            { -1.064371635460454, 0.06315929113835927, 0.8724690734011817, 1.0012123443221, -0.8724690734011935 },
            { -0.538426545270748, 0.8113854946777804, 0.650187960051466, -0.2729589494070267, -0.6501879600514787 },
            { 0.008528502381242828, 1.589501131547324, 0.4190273708339124, -1.59802963392856, -0.4190273708339264 },
            { 0.4932189948815581, 2.279037233052433, 0.2141817618291165, -2.772256227933984, -0.214181761829132 },
            { 0.8418071041301761, 2.774949757852314, 0.06685734627785214, -3.616756861982482, -0.06685734627786814 },
            { -0.9550412271225792, -0.9100824542451497, 1.955041227122563, 1.865123681367735, -1.955041227122576 },
            { -0.7706418936781961, -0.5412837873563825, 1.770641893678179, 1.311925681034585, -1.770641893678192 },
            { -0.4684203544308257, 0.06315929113835934, 1.468420354430809, 0.4052610632924725, -1.468420354430822 },
            { -0.09430725266111564, 0.8113854946777805, 1.094307252661098, -0.7170782420166586, -1.094307252661111 },
            { 0.2947505657736552, 1.589501131547324, 0.7052494342263244, -1.884251697320972, -0.7052494342263389 },
            { 0.6395186165262097, 2.279037233052433, 0.3604813834737681, -2.918555849578635, -0.3604813834737837 },
            { 0.8874748789261502, 2.774949757852314, 0.1125251210738261, -3.662424636778456, -0.1125251210738423 },
            { -0.1615972243519661, -0.9100824542451499, 2.748485229893175, 1.071679678597123, -2.74848522989319 },
            { -0.0520354663032098, -0.5412837873563825, 2.489248321053164, 0.5933192536595991, -2.48924832105318 },
            { 0.127530926598802, 0.06315929113835934, 2.064371635460435, -0.1906902177371543, -2.06437163546045 },
            { 0.3498120399485162, 0.8113854946777804, 1.538426545270729, -1.16119753462629, -1.538426545270743 },
            { 0.5809726291660676, 1.589501131547323, 0.9914714976187361, -2.170473760713384, -0.9914714976187511 },
            { 0.7858182381708615, 2.279037233052433, 0.5067810051184195, -3.064855471223287, -0.5067810051184353 },
            { 0.9331426537221245, 2.774949757852314, 0.1581928958698005, -3.708092411574431, -0.1581928958698165 },
            { 0.4946828119213179, -0.9100824542451498, 3.404765266166458, 0.4153996423238396, -3.404765266166475 },
            { 0.5423442890129496, -0.5412837873563821, 3.083628076369323, -0.00106050165655953, -3.08362807636934 },
            { 0.6204591319485436, 0.06315929113835934, 2.557299840810177, -0.6836184230868954, -2.557299840810193 },
            { 0.7171557018146937, 0.8113854946777805, 1.905770207136905, -1.528541196492467, -1.905770207136921 },
            { 0.8177150148788148, 1.589501131547324, 1.228213883331482, -2.407216146426131, -1.228213883331498 },
            { 0.9068268042000354, 2.279037233052433, 0.6277895711475935, -3.185864037252461, -0.627789571147609 },
            { 0.9709157653657534, 2.774949757852314, 0.1959660075134291, -3.745865523218059, -0.1959660075134456 },
            { 0.9005038704957511, -0.9100824542451497, 3.810586324740891, 0.009578583749407217, -3.81058632474091 },
            { 0.9098883375373397, -0.5412837873563823, 3.451172124893713, -0.3686045501809489, -3.451172124893731 },
            { 0.9252690226046234, 0.06315929113835934, 2.862109731466256, -0.9884283137429746, -2.862109731466273 },
            { 0.9443084193736098, 0.8113854946777805, 2.132922924695821, -1.755693914051383, -2.132922924695837 },
            { 0.9641083839731274, 1.589501131547324, 1.374607252425795, -2.553609515520443, -1.374607252425811 },
            { 0.9816543498334428, 2.279037233052433, 0.7026171167810004, -3.260691582885868, -0.7026171167810166 },
            { 0.9942733616746626, 2.774949757852314, 0.2193236038223383, -3.769223119526969, -0.2193236038223548 } } };
    alignas(32) static const double FE16_C0_D10_Q49[1][49][5] =
        { { { -2.810586324740908, -0.900503870495761, 0.08991754575484795, -0.08991754575484795, 3.711090195236669 },
            { -2.451172124893729, -0.9098883375373485, 0.4587162126436152, -0.4587162126436152, 3.361060462431078 },
            { -1.862109731466272, -0.9252690226046308, 1.063159291138356, -1.063159291138356, 2.787378754070903 },
            { -1.132922924695838, -0.944308419373617, 1.811385494677777, -1.811385494677777, 2.077231344069455 },
            { -0.3746072524258124, -0.9641083839731338, 2.589501131547318, -2.589501131547318, 1.338715636398947 },
            { 0.297382883218981, -0.9816543498334493, 3.279037233052426, -3.279037233052426, 0.6842714666144688 },
            { 0.7806763961776416, -0.9942733616746693, 3.774949757852304, -3.774949757852304, 0.213596965497028 },
            { -2.404765266166474, -0.4946828119213267, 0.08991754575484825, -0.08991754575484825, 2.899448078087801 },
            { -2.083628076369338, -0.5423442890129571, 0.4587162126436155, -0.4587162126436155, 2.625972365382295 },
            { -1.557299840810191, -0.6204591319485502, 1.063159291138356, -1.063159291138356, 2.177758972758742 },
            { -0.9057702071369206, -0.7171557018146996, 1.811385494677777, -1.811385494677777, 1.62292590895162 },
            { -0.2282138833314995, -0.8177150148788208, 2.589501131547318, -2.589501131547318, 1.045928898210321 },
            { 0.3722104288523886, -0.9068268042000419, 3.279037233052426, -3.279037233052426, 0.5346163753476536 },
            { 0.8040339924865511, -0.9709157653657602, 3.774949757852305, -3.774949757852305, 0.1668817728792096 },
            { -1.748485229893189, 0.1615972243519586, 0.08991754575484837, -0.08991754575484837, 1.58688800554123 },
            { -1.489248321053178, 0.05203546630320229, 0.4587162126436154, -0.4587162126436154, 1.437212854749976 },
            { -1.064371635460449, -0.1275309265988078, 1.063159291138356, -1.063159291138356, 1.191902562059257 },
            { -0.5384265452707427, -0.3498120399485219, 1.811385494677776, -1.811385494677776, 0.888238585219265 },
            { 0.008528502381247879, -0.5809726291660736, 2.589501131547318, -2.589501131547318, 0.572444126784826 },
            { 0.4932189948815626, -0.7858182381708678, 3.279037233052426, -3.279037233052426, 0.2925992432893055 },
            { 0.8418071041301801, -0.9331426537221311, 3.774949757852305, -3.774949757852305, 0.09133554959195143 },
            { -0.9550412271225739, 0.9550412271225732, 0.08991754575484862, -0.08991754575484862, 0.0 },
            { -0.7706418936781908, 0.7706418936781904, 0.4587162126436156, -0.4587162126436156, 0.0 },
            { -0.4684203544308203, 0.4684203544308205, 1.063159291138356, -1.063159291138356, 0.0 },
            { -0.09430725266111019, 0.09430725266111048, 1.811385494677776, -1.811385494677776, 0.0 },
            { 0.2947505657736605, -0.294750565773661, 2.589501131547317, -2.589501131547317, 0.0 },
            { 0.6395186165262142, -0.639518616526216, 3.279037233052425, -3.279037233052425, 0.0 },
            { 0.8874748789261543, -0.887474878926157, 3.774949757852305, -3.774949757852305, 0.0 },
            { -0.1615972243519597, 1.748485229893188, 0.08991754575484875, -0.08991754575484875, -1.586888005541228 },
            { -0.05203546630320351, 1.489248321053178, 0.4587162126436156, -0.4587162126436156, -1.437212854749974 },
            { 0.1275309265988084, 1.064371635460449, 1.063159291138356, -1.063159291138356, -1.191902562059257 },
            { 0.3498120399485224, 0.5384265452707429, 1.811385494677776, -1.811385494677776, -0.8882385852192649 },
            { 0.5809726291660733, -0.008528502381248526, 2.589501131547317, -2.589501131547317, -0.5724441267848244 },
            { 0.7858182381708664, -0.4932189948815644, 3.279037233052425, -3.279037233052425, -0.2925992432893016 },
            { 0.9331426537221285, -0.8418071041301828, 3.774949757852305, -3.774949757852305, -0.09133554959194533 },
            { 0.494682811921326, 2.404765266166474, 0.08991754575484887, -0.08991754575484887, -2.899448078087799 },
            { 0.5423442890129571, 2.083628076369338, 0.4587162126436157, -0.4587162126436157, -2.625972365382295 },
            { 0.6204591319485511, 1.557299840810192, 1.063159291138356, -1.063159291138356, -2.177758972758743 },
            { 0.7171557018147002, 0.9057702071369205, 1.811385494677776, -1.811385494677776, -1.622925908951621 },
            { 0.8177150148788205, 0.2282138833314986, 2.589501131547317, -2.589501131547317, -1.045928898210319 },
            { 0.9068268042000404, -0.3722104288523904, 3.279037233052425, -3.279037233052425, -0.5346163753476496 },
            { 0.9709157653657576, -0.8040339924865536, 3.774949757852305, -3.774949757852305, -0.1668817728792035 },
            { 0.9005038704957602, 2.810586324740908, 0.08991754575484895, -0.08991754575484895, -3.711090195236668 },
            { 0.9098883375373484, 2.45117212489373, 0.4587162126436156, -0.4587162126436156, -3.361060462431078 },
            { 0.9252690226046316, 1.862109731466272, 1.063159291138356, -1.063159291138356, -2.787378754070904 },
            { 0.944308419373617, 1.132922924695837, 1.811385494677776, -1.811385494677776, -2.077231344069454 },
            { 0.9641083839731334, 0.3746072524258114, 2.589501131547317, -2.589501131547317, -1.338715636398945 },
            { 0.981654349833448, -0.297382883218983, 3.279037233052425, -3.279037233052425, -0.6842714666144648 },
            { 0.9942733616746667, -0.7806763961776446, 3.774949757852305, -3.774949757852305, -0.2135969654970219 } } };
    alignas(32) static const double FE16_C0_Q49[1][49][6] =
        { { { 0.8624244361025749, -0.02363659740277002, -0.02146874080939055, 0.002236611944281942, 0.08565964255192414, 0.09478464761337956 },
            { 0.6260305982320046, -0.02151290165169063, -0.08837648269314125, 0.01033392012997215, 0.3957771515781187, 0.07774771440473618 },
            { 0.3084315815026736, -0.01798465447603435, -0.1245013629928625, 0.01986273323843486, 0.7607196383164689, 0.05347206441131927 },
            { 0.03543929416267128, -0.01353520113751297, -0.04270669737831205, 0.0252197303305776, 0.9658864117649357, 0.0296964622576404 },
            { -0.1074586758037479, -0.008811877994089196, 0.1908142308987769, 0.02323534507865832, 0.8898867588974482, 0.01233421892295345 },
            { -0.1139454275960456, -0.004544342181633655, 0.5242513387049099, 0.01503901749016921, 0.5759769216262262, 0.00322249195637405 },
            { -0.04881804555638587, -0.00142756028301928, 0.8375432698255753, 0.005404442989879767, 0.2069838962851253, 0.0003139967388248929 },
            { 0.5978619981700886, -0.09441111444870158, -0.02146874080939055, 0.01135922034494406, 0.07653703415126197, 0.4301216025917975 },
            { 0.4176882450793233, -0.08823283402187905, -0.08837648269314125, 0.05248352360967481, 0.3536275480984162, 0.352809999927606 },
            { 0.1781478492734307, -0.07687880819770677, -0.1245013629928625, 0.1008781000589046, 0.6797042714959993, 0.2426499503622346 },
            { -0.02244754148289256, -0.0607109624193334, -0.04270669737831205, 0.1280850147462928, 0.8630211273492205, 0.1347590591850247 },
            { -0.1184898029318446, -0.04141776930521639, 0.1908142308987769, 0.1180067938088454, 0.7951153101672611, 0.05597123736217727 },
            { -0.10768242458169, -0.02220814339804257, 0.5242513387049099, 0.0763795945376375, 0.5146363445787578, 0.0146232901584273 },
            { -0.04419116736576674, -0.007165322070527795, 0.8375432698255754, 0.02744788112246194, 0.1849404581525429, 0.001424880335714323 },
            { 0.2571500748943296, -0.1217357921352177, -0.02146874080939055, 0.02611199289234355, 0.06178426160386248, 0.7981582035540725 },
            { 0.1522325702199639, -0.1246615387808259, -0.08837648269314125, 0.1206464311673418, 0.285464640540749, 0.6546943795459121 },
            { 0.01661087229659385, -0.1229669828451063, -0.1245013629928625, 0.2318934004043382, 0.5486889711505657, 0.450275101986471 },
            { -0.08876210691847655, -0.1097039420883818, -0.04270669737831205, 0.2944352599128458, 0.6966708821826675, 0.250066604289657 },
            { -0.1249909080808916, -0.0828088505199826, 0.1908142308987769, 0.2712679627309381, 0.6418541412451684, 0.1038634237259905 },
            { -0.09459187788600246, -0.04781121206975434, 0.5242513387049099, 0.1755774929196237, 0.4154384461967716, 0.02713581213445154 },
            { -0.03642009992949465, -0.01615559847555263, 0.8375432698255754, 0.06309578078557344, 0.1492925584894315, 0.002644089304467039 },
            { -0.01098703181202573, -0.01098703181202572, -0.02146874080939053, 0.04394812724810312, 0.04394812724810298, 0.9555465499372358 },
            { -0.05076388396351129, -0.05076388396351134, -0.08837648269314125, 0.2030555358540455, 0.2030555358540454, 0.7837931789120729 },
            { -0.09757279644436297, -0.09757279644436299, -0.1245013629928625, 0.3902911857774519, 0.3902911857774519, 0.5390645843266845 },
            { -0.1238882677619391, -0.1238882677619392, -0.04270669737831205, 0.4955530710477567, 0.4955530710477565, 0.2993770908066771 },
            { -0.1141402629970133, -0.1141402629970134, 0.1908142308987769, 0.4565610519880533, 0.4565610519880532, 0.124344191119143 },
            { -0.07387699238954938, -0.07387699238954945, 0.5242513387049098, 0.2955079695581977, 0.2955079695581976, 0.03248670695779358 },
            { -0.02654854240937558, -0.02654854240937561, 0.8375432698255754, 0.1061941696375025, 0.1061941696375023, 0.003165475718171012 },
            { -0.1217357921352177, 0.2571500748943296, -0.02146874080939055, 0.06178426160386268, 0.02611199289234344, 0.7981582035540725 },
            { -0.1246615387808259, 0.1522325702199636, -0.08837648269314125, 0.285464640540749, 0.1206464311673419, 0.6546943795459126 },
            { -0.1229669828451062, 0.01661087229659389, -0.1245013629928625, 0.5486889711505658, 0.231893400404338, 0.4502751019864709 },
            { -0.1097039420883817, -0.08876210691847662, -0.04270669737831205, 0.6966708821826676, 0.2944352599128457, 0.250066604289657 },
            { -0.08280885051998249, -0.1249909080808916, 0.1908142308987769, 0.6418541412451685, 0.271267962730938, 0.1038634237259905 },
            { -0.04781121206975424, -0.09459187788600253, 0.5242513387049099, 0.4154384461967717, 0.1755774929196236, 0.02713581213445154 },
            { -0.01615559847555257, -0.0364200999294947, 0.8375432698255754, 0.1492925584894317, 0.06309578078557325, 0.002644089304467039 },
            { -0.09441111444870155, 0.5978619981700886, -0.02146874080939055, 0.0765370341512621, 0.01135922034494392, 0.4301216025917975 },
            { -0.08823283402187897, 0.4176882450793233, -0.08837648269314125, 0.3536275480984163, 0.0524835236096747, 0.352809999927606 },
            { -0.07687880819770654, 0.1781478492734308, -0.1245013629928625, 0.6797042714959994, 0.1008781000589044, 0.2426499503622344 },
            { -0.06071096241933321, -0.02244754148289255, -0.04270669737831205, 0.8630211273492208, 0.1280850147462926, 0.1347590591850246 },
            { -0.04141776930521627, -0.1184898029318446, 0.1908142308987769, 0.7951153101672612, 0.1180067938088453, 0.05597123736217727 },
            { -0.02220814339804247, -0.10768242458169, 0.5242513387049099, 0.514636344578758, 0.07637959453763735, 0.0146232901584273 },
            { -0.007165322070527736, -0.04419116736576677, 0.8375432698255754, 0.1849404581525431, 0.02744788112246175, 0.001424880335714323 },
            { -0.02363659740277012, 0.8624244361025747, -0.02146874080939055, 0.08565964255192417, 0.002236611944281803, 0.09478464761337987 },
            { -0.02151290165169072, 0.6260305982320042, -0.08837648269314125, 0.3957771515781189, 0.01033392012997211, 0.07774771440473678 },
            { -0.01798465447603422, 0.3084315815026735, -0.1245013629928625, 0.760719638316469, 0.01986273323843477, 0.05347206441131927 },
            { -0.01353520113751291, 0.03543929416267112, -0.04270669737831205, 0.9658864117649356, 0.02521973033057774, 0.02969646225764062 },
            { -0.008811877994089076, -0.107458675803748, 0.1908142308987769, 0.8898867588974482, 0.02323534507865835, 0.01233421892295351 },
            { -0.004544342181633541, -0.1139454275960457, 0.5242513387049099, 0.5759769216262263, 0.01503901749016905, 0.00322249195637405 },
            { -0.001427560283019225, -0.0488180455563859, 0.8375432698255754, 0.2069838962851254, 0.005404442989879504, 0.000313996738824917 } } };
    alignas(32) static const double FE18_C2_D01_Q49[1][1][2] = { { { -1.0, 1.0 } } };
    alignas(32) static const double FE18_C2_Q49[1][49][3] =
        { { { 0.9526465811852268, 0.02487403237606073, 0.0224793864387125 },
            { 0.8627930312234321, 0.02252791561566352, 0.1146790531609042 },
            { 0.7155274328665678, 0.01868274434884274, 0.2657898227845895 },
            { 0.5332307311739594, 0.01392289515659603, 0.4528463736694446 },
            { 0.343651813106453, 0.008972904006716695, 0.6473752828868302 },
            { 0.1756542791952546, 0.004586412541637936, 0.8197593082631076 },
            { 0.05483090095558923, 0.00143165958133301, 0.9437374394630776 },
            { 0.8511913165416183, 0.1263292970196692, 0.0224793864387125 },
            { 0.7709070190923345, 0.1144139277467613, 0.1146790531609042 },
            { 0.6393249602025477, 0.09488521701286287, 0.2657898227845895 },
            { 0.4764425517842301, 0.07071107454632534, 0.4528463736694446 },
            { 0.3070534708328747, 0.04557124628029494, 0.6473752828868302 },
            { 0.1569473927869027, 0.02329329894998982, 0.8197593082631076 },
            { 0.04899150187836195, 0.007271058658560332, 0.9437374394630778 },
            { 0.6871213074732972, 0.2903993060879904, 0.0224793864387125 },
            { 0.6223120802632945, 0.2630088665758011, 0.1146790531609042 },
            { 0.5160929088651123, 0.2181172683502983, 0.2657898227845895 },
            { 0.3846066363176858, 0.1625469900128697, 0.4528463736694446 },
            { 0.2478678744046879, 0.1047568427084817, 0.6473752828868302 },
            { 0.1266952512796092, 0.05354544045728332, 0.8197593082631076 },
            { 0.03954822396745468, 0.0167143365694676, 0.9437374394630778 },
            { 0.4887603067806437, 0.4887603067806437, 0.02247938643871252 },
            { 0.442660473419548, 0.4426604734195478, 0.1146790531609042 },
            { 0.3671050886077052, 0.3671050886077054, 0.2657898227845895 },
            { 0.2735768131652777, 0.2735768131652778, 0.4528463736694446 },
            { 0.1763123585565848, 0.1763123585565848, 0.6473752828868302 },
            { 0.09012034586844622, 0.09012034586844622, 0.8197593082631074 },
            { 0.02813128026846114, 0.02813128026846114, 0.9437374394630778 },
            { 0.2903993060879904, 0.6871213074732971, 0.0224793864387125 },
            { 0.2630088665758013, 0.6223120802632945, 0.1146790531609042 },
            { 0.2181172683502983, 0.5160929088651123, 0.2657898227845895 },
            { 0.1625469900128697, 0.3846066363176858, 0.4528463736694446 },
            { 0.1047568427084817, 0.2478678744046879, 0.6473752828868302 },
            { 0.05354544045728332, 0.1266952512796092, 0.8197593082631076 },
            { 0.0167143365694676, 0.03954822396745468, 0.9437374394630778 },
            { 0.1263292970196692, 0.8511913165416183, 0.0224793864387125 },
            { 0.1144139277467613, 0.7709070190923345, 0.1146790531609042 },
            { 0.09488521701286277, 0.6393249602025478, 0.2657898227845895 },
            { 0.07071107454632526, 0.4764425517842301, 0.4528463736694446 },
            { 0.04557124628029494, 0.3070534708328747, 0.6473752828868302 },
            { 0.02329329894998982, 0.1569473927869027, 0.8197593082631076 },
            { 0.007271058658560332, 0.04899150187836195, 0.9437374394630778 },
            { 0.02487403237606078, 0.9526465811852267, 0.0224793864387125 },
            { 0.02252791561566372, 0.8627930312234321, 0.1146790531609042 },
            { 0.01868274434884274, 0.7155274328665678, 0.2657898227845895 },
            { 0.01392289515659617, 0.5332307311739592, 0.4528463736694446 },
            { 0.008972904006716751, 0.343651813106453, 0.6473752828868302 },
            { 0.004586412541637936, 0.1756542791952546, 0.8197593082631076 },
            { 0.001431659581333028, 0.05483090095558925, 0.9437374394630778 } } };
    // Unstructured piecewise computations
    const double J_c0 = coordinate_dofs[0] * FE18_C2_D01_Q49[0][0][0] + coordinate_dofs[2] * FE18_C2_D01_Q49[0][0][1];
    const double J_c3 = coordinate_dofs[1] * FE18_C2_D01_Q49[0][0][0] + coordinate_dofs[5] * FE18_C2_D01_Q49[0][0][1];
    const double J_c1 = coordinate_dofs[0] * FE18_C2_D01_Q49[0][0][0] + coordinate_dofs[4] * FE18_C2_D01_Q49[0][0][1];
    const double J_c2 = coordinate_dofs[1] * FE18_C2_D01_Q49[0][0][0] + coordinate_dofs[3] * FE18_C2_D01_Q49[0][0][1];
    const double w0_d1_c2 = w[0][12] * FE18_C2_D01_Q49[0][0][0] + w[0][14] * FE18_C2_D01_Q49[0][0][1];
    double w0_d0_c2 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c2 += w[0][ic + 12] * FE18_C2_D01_Q49[0][0][ic];
    const double w0_d1_c3 = w[0][15] * FE18_C2_D01_Q49[0][0][0] + w[0][17] * FE18_C2_D01_Q49[0][0][1];
    double w0_d0_c3 = 0.0;
    for (int ic = 0; ic < 2; ++ic)
        w0_d0_c3 += w[0][ic + 15] * FE18_C2_D01_Q49[0][0][ic];
    alignas(32) double sp[25];
    sp[0] = J_c0 * J_c3;
    sp[1] = J_c1 * J_c2;
    sp[2] = sp[0] + -1 * sp[1];
    sp[3] = J_c0 / sp[2];
    sp[4] = -1 * J_c1 / sp[2];
    sp[5] = J_c3 / sp[2];
    sp[6] = -1 * J_c2 / sp[2];
    sp[7] = -1 * (2 * w[3][0] / 3) + w[2][0];
    sp[8] = w0_d1_c2 * sp[3];
    sp[9] = w0_d0_c2 * sp[4];
    sp[10] = sp[8] + sp[9];
    sp[11] = -1 * sp[10] * w[4][0];
    sp[12] = w0_d0_c2 * sp[5];
    sp[13] = w0_d1_c2 * sp[6];
    sp[14] = sp[12] + sp[13];
    sp[15] = -1 * sp[14] * w[4][0];
    sp[16] = w0_d1_c3 * sp[3];
    sp[17] = w0_d0_c3 * sp[4];
    sp[18] = sp[16] + sp[17];
    sp[19] = -1 * sp[18] * w[6][0];
    sp[20] = w0_d0_c3 * sp[5];
    sp[21] = w0_d1_c3 * sp[6];
    sp[22] = sp[20] + sp[21];
    sp[23] = -1 * sp[22] * w[6][0];
    sp[24] = std::abs(sp[2]);
    alignas(32) double BF0[3] = {};
    alignas(32) double BF1[3] = {};
    alignas(32) double BF2[3] = {};
    alignas(32) double BF3[6] = {};
    alignas(32) double BF4[6] = {};
    alignas(32) double BF5[6] = {};
    alignas(32) double BF6[6] = {};
    alignas(32) double BF7[3] = {};
    for (int iq = 0; iq < 49; ++iq)
    {
        // Quadrature loop body setup (num_points=49)
        // Unstructured varying computations for num_points=49
        const double w0_d1_c1 = w[0][6] * FE16_C0_D01_Q49[0][iq][0] + w[0][8] * FE16_C0_D01_Q49[0][iq][1] + w[0][9] * FE16_C0_D01_Q49[0][iq][2] + w[0][10] * FE16_C0_D01_Q49[0][iq][3] + w[0][11] * FE16_C0_D01_Q49[0][iq][4];
        const double w0_d0_c1 = w[0][6] * FE16_C0_D10_Q49[0][iq][0] + w[0][7] * FE16_C0_D10_Q49[0][iq][1] + w[0][9] * FE16_C0_D10_Q49[0][iq][2] + w[0][10] * FE16_C0_D10_Q49[0][iq][3] + w[0][11] * FE16_C0_D10_Q49[0][iq][4];
        const double w0_d0_c0 = w[0][0] * FE16_C0_D10_Q49[0][iq][0] + w[0][1] * FE16_C0_D10_Q49[0][iq][1] + w[0][3] * FE16_C0_D10_Q49[0][iq][2] + w[0][4] * FE16_C0_D10_Q49[0][iq][3] + w[0][5] * FE16_C0_D10_Q49[0][iq][4];
        const double w0_d1_c0 = w[0][0] * FE16_C0_D01_Q49[0][iq][0] + w[0][2] * FE16_C0_D01_Q49[0][iq][1] + w[0][3] * FE16_C0_D01_Q49[0][iq][2] + w[0][4] * FE16_C0_D01_Q49[0][iq][3] + w[0][5] * FE16_C0_D01_Q49[0][iq][4];
        double w0_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c3 += w[0][ic + 15] * FE18_C2_Q49[0][iq][ic];
        double w0_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w0_c2 += w[0][ic + 12] * FE18_C2_Q49[0][iq][ic];
        double w10 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w10 += w[10][ic] * FE18_C2_Q49[0][iq][ic];
        double w1_c3 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c3 += w[1][ic + 15] * FE18_C2_Q49[0][iq][ic];
        double w1_c2 = 0.0;
        for (int ic = 0; ic < 3; ++ic)
            w1_c2 += w[1][ic + 12] * FE18_C2_Q49[0][iq][ic];
        double w9_c0 = 0.0;
        for (int ic = 0; ic < 6; ++ic)
            w9_c0 += w[9][ic] * FE16_C0_Q49[0][iq][ic];
        double w9_c1 = 0.0;
        for (int ic = 0; ic < 6; ++ic)
            w9_c1 += w[9][ic + 6] * FE16_C0_Q49[0][iq][ic];
        alignas(32) double sv49[253];
        sv49[0] = w0_d1_c1 * sp[3];
        sv49[1] = w0_d0_c1 * sp[4];
        sv49[2] = sv49[0] + sv49[1];
        sv49[3] = sv49[2] + sv49[2];
        sv49[4] = w0_d0_c0 * sp[5];
        sv49[5] = w0_d1_c0 * sp[6];
        sv49[6] = sv49[4] + sv49[5];
        sv49[7] = sv49[6] + sv49[6];
        sv49[8] = sv49[3] / 2 + sv49[7] / 2;
        sv49[9] = sv49[8] * sp[7];
        sv49[10] = 2 * w[3][0] * (sv49[3] / 2);
        sv49[11] = sv49[9] + sv49[10];
        sv49[12] = w0_c3 + -1 * w0_c2;
        sv49[13] = std::abs(1 + -1 * w10);
        sv49[14] = 1 + -1 * w10 + sv49[13];
        sv49[15] = sv49[14] / 2 / w[11][0];
        sv49[16] = std::pow(sv49[15], 1 / (1 + -1 * w[12][0]));
        sv49[17] = std::pow(1 + sv49[16], -1 * w[12][0]);
        sv49[18] = 1 + 0.1 * (-1 + sv49[12]) + -1 * w10;
        sv49[19] = std::abs(sv49[18]);
        sv49[20] = sv49[18] + sv49[19];
        sv49[21] = sv49[20] / 2 / w[11][0];
        sv49[22] = std::pow(sv49[21], 1 / (1 + -1 * w[12][0]));
        sv49[23] = std::pow(1 + sv49[22], -1 * w[12][0]);
        sv49[24] = sv49[17] + sv49[23];
        sv49[25] = (-1 + (1 + 0.1 * (-1 + sv49[12]))) * (0.5 * sv49[24]);
        sv49[26] = 1 + 0.2 * (-1 + sv49[12]) + -1 * (1 + 0.1 * (-1 + sv49[12]));
        sv49[27] = 1 + 0.2 * (-1 + sv49[12]) + -1 * w10;
        sv49[28] = std::abs(sv49[27]);
        sv49[29] = sv49[27] + sv49[28];
        sv49[30] = sv49[29] / 2 / w[11][0];
        sv49[31] = std::pow(sv49[30], 1 / (1 + -1 * w[12][0]));
        sv49[32] = std::pow(1 + sv49[31], -1 * w[12][0]);
        sv49[33] = sv49[23] + sv49[32];
        sv49[34] = sv49[26] * (0.5 * sv49[33]);
        sv49[35] = sv49[25] + sv49[34];
        sv49[36] = 1 + 0.3 * (-1 + sv49[12]) + -1 * (1 + 0.2 * (-1 + sv49[12]));
        sv49[37] = 1 + 0.3 * (-1 + sv49[12]) + -1 * w10;
        sv49[38] = std::abs(sv49[37]);
        sv49[39] = sv49[37] + sv49[38];
        sv49[40] = sv49[39] / 2 / w[11][0];
        sv49[41] = std::pow(sv49[40], 1 / (1 + -1 * w[12][0]));
        sv49[42] = std::pow(1 + sv49[41], -1 * w[12][0]);
        sv49[43] = sv49[32] + sv49[42];
        sv49[44] = sv49[36] * (0.5 * sv49[43]);
        sv49[45] = sv49[35] + sv49[44];
        sv49[46] = 1 + 0.4 * (-1 + sv49[12]) + -1 * (1 + 0.3 * (-1 + sv49[12]));
        sv49[47] = 1 + 0.4 * (-1 + sv49[12]) + -1 * w10;
        sv49[48] = std::abs(sv49[47]);
        sv49[49] = sv49[47] + sv49[48];
        sv49[50] = sv49[49] / 2 / w[11][0];
        sv49[51] = std::pow(sv49[50], 1 / (1 + -1 * w[12][0]));
        sv49[52] = std::pow(1 + sv49[51], -1 * w[12][0]);
        sv49[53] = sv49[42] + sv49[52];
        sv49[54] = sv49[46] * (0.5 * sv49[53]);
        sv49[55] = sv49[45] + sv49[54];
        sv49[56] = 1 + 0.5 * (-1 + sv49[12]) + -1 * (1 + 0.4 * (-1 + sv49[12]));
        sv49[57] = 1 + 0.5 * (-1 + sv49[12]) + -1 * w10;
        sv49[58] = std::abs(sv49[57]);
        sv49[59] = sv49[57] + sv49[58];
        sv49[60] = sv49[59] / 2 / w[11][0];
        sv49[61] = std::pow(sv49[60], 1 / (1 + -1 * w[12][0]));
        sv49[62] = std::pow(1 + sv49[61], -1 * w[12][0]);
        sv49[63] = sv49[52] + sv49[62];
        sv49[64] = sv49[56] * (0.5 * sv49[63]);
        sv49[65] = sv49[55] + sv49[64];
        sv49[66] = 1 + 0.6 * (-1 + sv49[12]) + -1 * (1 + 0.5 * (-1 + sv49[12]));
        sv49[67] = 1 + 0.6 * (-1 + sv49[12]) + -1 * w10;
        sv49[68] = std::abs(sv49[67]);
        sv49[69] = sv49[67] + sv49[68];
        sv49[70] = sv49[69] / 2 / w[11][0];
        sv49[71] = std::pow(sv49[70], 1 / (1 + -1 * w[12][0]));
        sv49[72] = std::pow(1 + sv49[71], -1 * w[12][0]);
        sv49[73] = sv49[62] + sv49[72];
        sv49[74] = sv49[66] * (0.5 * sv49[73]);
        sv49[75] = sv49[65] + sv49[74];
        sv49[76] = 1 + 0.7 * (-1 + sv49[12]) + -1 * (1 + 0.6 * (-1 + sv49[12]));
        sv49[77] = 1 + 0.7 * (-1 + sv49[12]) + -1 * w10;
        sv49[78] = std::abs(sv49[77]);
        sv49[79] = sv49[77] + sv49[78];
        sv49[80] = sv49[79] / 2 / w[11][0];
        sv49[81] = std::pow(sv49[80], 1 / (1 + -1 * w[12][0]));
        sv49[82] = std::pow(1 + sv49[81], -1 * w[12][0]);
        sv49[83] = sv49[72] + sv49[82];
        sv49[84] = sv49[76] * (0.5 * sv49[83]);
        sv49[85] = sv49[75] + sv49[84];
        sv49[86] = 1 + 0.8 * (-1 + sv49[12]) + -1 * (1 + 0.7 * (-1 + sv49[12]));
        sv49[87] = 1 + 0.8 * (-1 + sv49[12]) + -1 * w10;
        sv49[88] = std::abs(sv49[87]);
        sv49[89] = sv49[87] + sv49[88];
        sv49[90] = sv49[89] / 2 / w[11][0];
        sv49[91] = std::pow(sv49[90], 1 / (1 + -1 * w[12][0]));
        sv49[92] = std::pow(1 + sv49[91], -1 * w[12][0]);
        sv49[93] = sv49[82] + sv49[92];
        sv49[94] = sv49[86] * (0.5 * sv49[93]);
        sv49[95] = sv49[85] + sv49[94];
        sv49[96] = 1 + 0.9 * (-1 + sv49[12]) + -1 * (1 + 0.8 * (-1 + sv49[12]));
        sv49[97] = 1 + 0.9 * (-1 + sv49[12]) + -1 * w10;
        sv49[98] = std::abs(sv49[97]);
        sv49[99] = sv49[97] + sv49[98];
        sv49[100] = sv49[99] / 2 / w[11][0];
        sv49[101] = std::pow(sv49[100], 1 / (1 + -1 * w[12][0]));
        sv49[102] = std::pow(1 + sv49[101], -1 * w[12][0]);
        sv49[103] = sv49[92] + sv49[102];
        sv49[104] = sv49[96] * (0.5 * sv49[103]);
        sv49[105] = sv49[95] + sv49[104];
        sv49[106] = sv49[12] + -1 * (1 + 0.9 * (-1 + sv49[12]));
        sv49[107] = sv49[12] + -1 * w10;
        sv49[108] = std::abs(sv49[107]);
        sv49[109] = sv49[107] + sv49[108];
        sv49[110] = sv49[109] / 2 / w[11][0];
        sv49[111] = std::pow(sv49[110], 1 / (1 + -1 * w[12][0]));
        sv49[112] = std::pow(1 + sv49[111], -1 * w[12][0]);
        sv49[113] = sv49[112] + sv49[102];
        sv49[114] = sv49[106] * (0.5 * sv49[113]);
        sv49[115] = sv49[105] + sv49[114];
        sv49[116] = w0_c3 + -1 * sv49[115];
        sv49[117] = w1_c3 + -1 * w1_c2;
        sv49[118] = 1 + 0.1 * (-1 + sv49[117]) + -1 * w10;
        sv49[119] = std::abs(sv49[118]);
        sv49[120] = sv49[118] + sv49[119];
        sv49[121] = sv49[120] / 2 / w[11][0];
        sv49[122] = std::pow(sv49[121], 1 / (1 + -1 * w[12][0]));
        sv49[123] = std::pow(1 + sv49[122], -1 * w[12][0]);
        sv49[124] = sv49[17] + sv49[123];
        sv49[125] = (-1 + (1 + 0.1 * (-1 + sv49[117]))) * (0.5 * sv49[124]);
        sv49[126] = 1 + 0.2 * (-1 + sv49[117]) + -1 * (1 + 0.1 * (-1 + sv49[117]));
        sv49[127] = 1 + 0.2 * (-1 + sv49[117]) + -1 * w10;
        sv49[128] = std::abs(sv49[127]);
        sv49[129] = sv49[127] + sv49[128];
        sv49[130] = sv49[129] / 2 / w[11][0];
        sv49[131] = std::pow(sv49[130], 1 / (1 + -1 * w[12][0]));
        sv49[132] = std::pow(1 + sv49[131], -1 * w[12][0]);
        sv49[133] = sv49[123] + sv49[132];
        sv49[134] = sv49[126] * (0.5 * sv49[133]);
        sv49[135] = sv49[125] + sv49[134];
        sv49[136] = 1 + 0.3 * (-1 + sv49[117]) + -1 * (1 + 0.2 * (-1 + sv49[117]));
        sv49[137] = 1 + 0.3 * (-1 + sv49[117]) + -1 * w10;
        sv49[138] = std::abs(sv49[137]);
        sv49[139] = sv49[137] + sv49[138];
        sv49[140] = sv49[139] / 2 / w[11][0];
        sv49[141] = std::pow(sv49[140], 1 / (1 + -1 * w[12][0]));
        sv49[142] = std::pow(1 + sv49[141], -1 * w[12][0]);
        sv49[143] = sv49[132] + sv49[142];
        sv49[144] = sv49[136] * (0.5 * sv49[143]);
        sv49[145] = sv49[135] + sv49[144];
        sv49[146] = 1 + 0.4 * (-1 + sv49[117]) + -1 * (1 + 0.3 * (-1 + sv49[117]));
        sv49[147] = 1 + 0.4 * (-1 + sv49[117]) + -1 * w10;
        sv49[148] = std::abs(sv49[147]);
        sv49[149] = sv49[147] + sv49[148];
        sv49[150] = sv49[149] / 2 / w[11][0];
        sv49[151] = std::pow(sv49[150], 1 / (1 + -1 * w[12][0]));
        sv49[152] = std::pow(1 + sv49[151], -1 * w[12][0]);
        sv49[153] = sv49[142] + sv49[152];
        sv49[154] = sv49[146] * (0.5 * sv49[153]);
        sv49[155] = sv49[145] + sv49[154];
        sv49[156] = 1 + 0.5 * (-1 + sv49[117]) + -1 * (1 + 0.4 * (-1 + sv49[117]));
        sv49[157] = 1 + 0.5 * (-1 + sv49[117]) + -1 * w10;
        sv49[158] = std::abs(sv49[157]);
        sv49[159] = sv49[157] + sv49[158];
        sv49[160] = sv49[159] / 2 / w[11][0];
        sv49[161] = std::pow(sv49[160], 1 / (1 + -1 * w[12][0]));
        sv49[162] = std::pow(1 + sv49[161], -1 * w[12][0]);
        sv49[163] = sv49[152] + sv49[162];
        sv49[164] = sv49[156] * (0.5 * sv49[163]);
        sv49[165] = sv49[155] + sv49[164];
        sv49[166] = 1 + 0.6 * (-1 + sv49[117]) + -1 * (1 + 0.5 * (-1 + sv49[117]));
        sv49[167] = 1 + 0.6 * (-1 + sv49[117]) + -1 * w10;
        sv49[168] = std::abs(sv49[167]);
        sv49[169] = sv49[167] + sv49[168];
        sv49[170] = sv49[169] / 2 / w[11][0];
        sv49[171] = std::pow(sv49[170], 1 / (1 + -1 * w[12][0]));
        sv49[172] = std::pow(1 + sv49[171], -1 * w[12][0]);
        sv49[173] = sv49[162] + sv49[172];
        sv49[174] = sv49[166] * (0.5 * sv49[173]);
        sv49[175] = sv49[165] + sv49[174];
        sv49[176] = 1 + 0.7 * (-1 + sv49[117]) + -1 * (1 + 0.6 * (-1 + sv49[117]));
        sv49[177] = 1 + 0.7 * (-1 + sv49[117]) + -1 * w10;
        sv49[178] = std::abs(sv49[177]);
        sv49[179] = sv49[177] + sv49[178];
        sv49[180] = sv49[179] / 2 / w[11][0];
        sv49[181] = std::pow(sv49[180], 1 / (1 + -1 * w[12][0]));
        sv49[182] = std::pow(1 + sv49[181], -1 * w[12][0]);
        sv49[183] = sv49[172] + sv49[182];
        sv49[184] = sv49[176] * (0.5 * sv49[183]);
        sv49[185] = sv49[175] + sv49[184];
        sv49[186] = 1 + 0.8 * (-1 + sv49[117]) + -1 * (1 + 0.7 * (-1 + sv49[117]));
        sv49[187] = 1 + 0.8 * (-1 + sv49[117]) + -1 * w10;
        sv49[188] = std::abs(sv49[187]);
        sv49[189] = sv49[187] + sv49[188];
        sv49[190] = sv49[189] / 2 / w[11][0];
        sv49[191] = std::pow(sv49[190], 1 / (1 + -1 * w[12][0]));
        sv49[192] = std::pow(1 + sv49[191], -1 * w[12][0]);
        sv49[193] = sv49[182] + sv49[192];
        sv49[194] = sv49[186] * (0.5 * sv49[193]);
        sv49[195] = sv49[185] + sv49[194];
        sv49[196] = 1 + 0.9 * (-1 + sv49[117]) + -1 * (1 + 0.8 * (-1 + sv49[117]));
        sv49[197] = 1 + 0.9 * (-1 + sv49[117]) + -1 * w10;
        sv49[198] = std::abs(sv49[197]);
        sv49[199] = sv49[197] + sv49[198];
        sv49[200] = sv49[199] / 2 / w[11][0];
        sv49[201] = std::pow(sv49[200], 1 / (1 + -1 * w[12][0]));
        sv49[202] = std::pow(1 + sv49[201], -1 * w[12][0]);
        sv49[203] = sv49[192] + sv49[202];
        sv49[204] = sv49[196] * (0.5 * sv49[203]);
        sv49[205] = sv49[195] + sv49[204];
        sv49[206] = sv49[117] + -1 * (1 + 0.9 * (-1 + sv49[117]));
        sv49[207] = sv49[117] + -1 * w10;
        sv49[208] = std::abs(sv49[207]);
        sv49[209] = sv49[207] + sv49[208];
        sv49[210] = sv49[209] / 2 / w[11][0];
        sv49[211] = std::pow(sv49[210], 1 / (1 + -1 * w[12][0]));
        sv49[212] = std::pow(1 + sv49[211], -1 * w[12][0]);
        sv49[213] = sv49[212] + sv49[202];
        sv49[214] = sv49[206] * (0.5 * sv49[213]);
        sv49[215] = sv49[205] + sv49[214];
        sv49[216] = w1_c3 + -1 * sv49[215];
        sv49[217] = sv49[116] + -1 * sv49[216];
        sv49[218] = sv49[11] + -1 * sv49[217];
        sv49[219] = w0_d1_c0 * sp[3];
        sv49[220] = w0_d0_c0 * sp[4];
        sv49[221] = sv49[219] + sv49[220];
        sv49[222] = w0_d0_c1 * sp[5];
        sv49[223] = w0_d1_c1 * sp[6];
        sv49[224] = sv49[222] + sv49[223];
        sv49[225] = sv49[221] + sv49[224];
        sv49[226] = 2 * w[3][0] * (sv49[225] / 2);
        sv49[227] = 2 * w[3][0] * (sv49[7] / 2);
        sv49[228] = sv49[9] + sv49[227];
        sv49[229] = sv49[228] + -1 * sv49[217];
        sv49[230] = std::pow(sv49[112], 3) / w[5][0];
        sv49[231] = sp[11] * sv49[230];
        sv49[232] = sp[15] * sv49[230];
        sv49[233] = w9_c0 * w[8][0];
        sv49[234] = sv49[233] * w[4][0];
        sv49[235] = w9_c1 * w[8][0];
        sv49[236] = sv49[235] * w[4][0];
        sv49[237] = sv49[236] * sv49[230];
        sv49[238] = sv49[234] * sv49[230];
        sv49[239] = sv49[231] + sv49[237];
        sv49[240] = sv49[232] + sv49[238];
        sv49[241] = std::pow(1 + -1 * sv49[112], 3) / w[7][0];
        sv49[242] = sp[19] * sv49[241];
        sv49[243] = sp[23] * sv49[241];
        sv49[244] = -1 * sv49[217] + sv49[9];
        sv49[245] = sv49[218] * sp[24];
        sv49[246] = sv49[226] * sp[24];
        sv49[247] = sv49[229] * sp[24];
        sv49[248] = sv49[239] * sp[24];
        sv49[249] = sv49[240] * sp[24];
        sv49[250] = sv49[242] * sp[24];
        sv49[251] = sv49[243] * sp[24];
        sv49[252] = sv49[244] * sp[24];
        const double fw0 = sv49[247] * weights49[iq];
        for (int i = 0; i < 3; ++i)
            BF0[i] += fw0 * FE18_C2_Q49[0][iq][i];
        const double fw1 = sv49[246] * weights49[iq];
        for (int i = 0; i < 3; ++i)
            BF1[i] += fw1 * FE18_C2_Q49[0][iq][i];
        const double fw2 = sv49[245] * weights49[iq];
        for (int i = 0; i < 3; ++i)
            BF2[i] += fw2 * FE18_C2_Q49[0][iq][i];
        const double fw3 = sv49[249] * weights49[iq];
        for (int i = 0; i < 6; ++i)
            BF3[i] += fw3 * FE16_C0_Q49[0][iq][i];
        const double fw4 = sv49[248] * weights49[iq];
        for (int i = 0; i < 6; ++i)
            BF4[i] += fw4 * FE16_C0_Q49[0][iq][i];
        const double fw5 = sv49[251] * weights49[iq];
        for (int i = 0; i < 6; ++i)
            BF5[i] += fw5 * FE16_C0_Q49[0][iq][i];
        const double fw6 = sv49[250] * weights49[iq];
        for (int i = 0; i < 6; ++i)
            BF6[i] += fw6 * FE16_C0_Q49[0][iq][i];
        const double fw7 = sv49[252] * weights49[iq];
        for (int i = 0; i < 3; ++i)
            BF7[i] += fw7 * FE18_C2_Q49[0][iq][i];
    }
    std::fill(A, A + 39, 0.0);
    for (int i = 0; i < 3; ++i)
        A[i] += BF0[i];
    for (int i = 0; i < 3; ++i)
        A[i + 3] += BF1[i];
    for (int i = 0; i < 3; ++i)
        A[i + 6] += BF1[i];
    for (int i = 0; i < 3; ++i)
        A[i + 9] += BF2[i];
    for (int i = 0; i < 6; ++i)
        A[i + 12] += BF3[i];
    for (int i = 0; i < 6; ++i)
        A[i + 18] += BF4[i];
    for (int i = 0; i < 6; ++i)
        A[i + 24] += BF5[i];
    for (int i = 0; i < 6; ++i)
        A[i + 30] += BF6[i];
    for (int i = 0; i < 3; ++i)
        A[i + 36] += BF7[i];
  }

};


class dual2d_form_0: public ufc::form
{
public:

  dual2d_form_0() : ufc::form()
  {
    // Do nothing
  }

  ~dual2d_form_0() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "d1c5cd747bf258fc68fdf14118ac7ae88dc62e0e474a419ae026fa5c994bf485bcef0b91fba207232e86926367121e70741152b43461772849ab4b11e0b59884";
  }

  std::size_t rank() const final override
  {
    return 2;
  }

  std::size_t num_coefficients() const final override
  {
    return 0;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new dual2d_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new dual2d_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new dual2d_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_6();
    case 1:
        return new dual2d_finite_element_6();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_6();
    case 1:
        return new dual2d_dofmap_6();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new dual2d_cell_integral_0_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};


class dual2d_form_1: public ufc::form
{
public:

  dual2d_form_1() : ufc::form()
  {
    // Do nothing
  }

  ~dual2d_form_1() override
  {
    // Do nothing
  }

  const char * signature() const final override
  {
    return "5436c52e41630806561e4a3f32cc9c99a6b2dae61bb9c8c278df5357533af1aab15a6b7210ca63b293396662ba081af21760af39f212c74b1272d2e08a8b9900";
  }

  std::size_t rank() const final override
  {
    return 1;
  }

  std::size_t num_coefficients() const final override
  {
    return 13;
  }

  std::size_t original_coefficient_position(std::size_t i) const final override
  {
    if (i >= 13)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    return position[i];
  }

  ufc::finite_element * create_coordinate_finite_element() const final override
  {
    return new dual2d_finite_element_1();
  }

  ufc::dofmap * create_coordinate_dofmap() const final override
  {
    return new dual2d_dofmap_1();
   }

  ufc::coordinate_mapping * create_coordinate_mapping() const final override
  {
    return new dual2d_coordinate_mapping_1();
  }

  ufc::finite_element * create_finite_element(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_finite_element_6();
    case 1:
        return new dual2d_finite_element_4();
    case 2:
        return new dual2d_finite_element_4();
    case 3:
        return new dual2d_finite_element_7();
    case 4:
        return new dual2d_finite_element_7();
    case 5:
        return new dual2d_finite_element_7();
    case 6:
        return new dual2d_finite_element_7();
    case 7:
        return new dual2d_finite_element_7();
    case 8:
        return new dual2d_finite_element_7();
    case 9:
        return new dual2d_finite_element_7();
    case 10:
        return new dual2d_finite_element_3();
    case 11:
        return new dual2d_finite_element_0();
    case 12:
        return new dual2d_finite_element_7();
    case 13:
        return new dual2d_finite_element_7();
    default:
        return nullptr;
    }
  }

  ufc::dofmap * create_dofmap(std::size_t i) const final override
  {
    switch (i)
    {
    case 0:
        return new dual2d_dofmap_6();
    case 1:
        return new dual2d_dofmap_4();
    case 2:
        return new dual2d_dofmap_4();
    case 3:
        return new dual2d_dofmap_7();
    case 4:
        return new dual2d_dofmap_7();
    case 5:
        return new dual2d_dofmap_7();
    case 6:
        return new dual2d_dofmap_7();
    case 7:
        return new dual2d_dofmap_7();
    case 8:
        return new dual2d_dofmap_7();
    case 9:
        return new dual2d_dofmap_7();
    case 10:
        return new dual2d_dofmap_3();
    case 11:
        return new dual2d_dofmap_0();
    case 12:
        return new dual2d_dofmap_7();
    case 13:
        return new dual2d_dofmap_7();
    default:
        return nullptr;
    }
  }

  std::size_t max_cell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_exterior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interior_facet_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_vertex_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_custom_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_cutcell_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_interface_subdomain_id() const final override
  {
    return 0;
  }

  std::size_t max_overlap_subdomain_id() const final override
  {
    return 0;
  }

  bool has_cell_integrals() const final override
  {
    return true;
  }

  bool has_exterior_facet_integrals() const final override
  {
    return false;
  }

  bool has_interior_facet_integrals() const final override
  {
    return false;
  }

  bool has_vertex_integrals() const final override
  {
    return false;
  }

  bool has_custom_integrals() const final override
  {
    return false;
  }

  bool has_cutcell_integrals() const final override
  {
    return false;
  }

  bool has_interface_integrals() const final override
  {
    return false;
  }

  bool has_overlap_integrals() const final override
  {
    return false;
  }

  ufc::cell_integral * create_cell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::exterior_facet_integral * create_exterior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_interior_facet_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_vertex_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_custom_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_cutcell_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_interface_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_overlap_integral(std::size_t subdomain_id) const final override
  {
    return nullptr;
  }

  ufc::cell_integral * create_default_cell_integral() const final override
  {
    return new dual2d_cell_integral_1_otherwise();
  }

  ufc::exterior_facet_integral * create_default_exterior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::interior_facet_integral * create_default_interior_facet_integral() const final override
  {
    return nullptr;
  }

  ufc::vertex_integral * create_default_vertex_integral() const final override
  {
    return nullptr;
  }

  ufc::custom_integral * create_default_custom_integral() const final override
  {
    return nullptr;
  }

  ufc::cutcell_integral * create_default_cutcell_integral() const final override
  {
    return nullptr;
  }

  ufc::interface_integral * create_default_interface_integral() const final override
  {
    return nullptr;
  }

  ufc::overlap_integral * create_default_overlap_integral() const final override
  {
    return nullptr;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/mesh/Mesh.h>
#include <dolfin/mesh/MultiMesh.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/fem/MultiMeshForm.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/MultiMeshFunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/function/MultiMeshCoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>
#include <dolfin/la/GenericVector.h>

namespace Dual2D
{

class CoefficientSpace_Etag: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Etag(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Etag(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_Etal: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Etal(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Etal(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_K: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_K(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_K(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_Kig: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Kig(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Kig(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_Kil: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Kil(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Kil(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_M: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_M(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_M(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_Mu: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_Mu(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_Mu(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_g: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_g(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_3>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_g(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_3>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_3>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_m: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_m(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_m(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_pe: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_pe(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_0>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_pe(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_0>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_0>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_rhoL: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_rhoL(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_rhoL(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_7>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_7>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_w: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_w(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_4>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_w(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_4>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class CoefficientSpace_w0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  CoefficientSpace_w0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_4>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  CoefficientSpace_w0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_4>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_4>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_a_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_6>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_a_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_6>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_a_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_6>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_a_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_6>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_a_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_a_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_a_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_a_MultiMeshFunctionSpace_1: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_a_MultiMeshFunctionSpace_1(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_a_FunctionSpace_1(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

class Form_a: public dolfin::Form
{
public:

  // Constructor
  Form_a(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::make_shared<const dual2d_form_0>();
  }

  // Destructor
  ~Form_a()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return "unnamed";
  }

  // Typedefs
  typedef Form_a_FunctionSpace_0 TestSpace;
  typedef Form_a_FunctionSpace_1 TrialSpace;
  typedef Form_a_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_a_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;

  // Coefficients
};

class MultiMeshForm_a: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_a(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V1, std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V1, V0)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_a(V1->part(part), V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Destructor
  ~MultiMeshForm_a()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return "unnamed";
  }

  // Typedefs
  typedef Form_a_FunctionSpace_0 TestSpace;
  typedef Form_a_FunctionSpace_1 TrialSpace;
  typedef Form_a_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_a_MultiMeshFunctionSpace_1 MultiMeshTrialSpace;

  // Coefficients
};

class Form_L_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  // Constructor for standard function space
  Form_L_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_6>(), *mesh))
  {
    // Do nothing
  }

  // Constructor for constrained function space
  Form_L_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::make_shared<const dolfin::FiniteElement>(std::make_shared<dual2d_finite_element_6>()),
                          std::make_shared<const dolfin::DofMap>(std::make_shared<dual2d_dofmap_6>(), *mesh, constrained_domain))
  {
    // Do nothing
  }

};

class Form_L_MultiMeshFunctionSpace_0: public dolfin::MultiMeshFunctionSpace
{
public:

  // Constructor for multimesh function space
  Form_L_MultiMeshFunctionSpace_0(std::shared_ptr<const dolfin::MultiMesh> multimesh): dolfin::MultiMeshFunctionSpace(multimesh)
  {
    // Create and add standard function spaces
    for (std::size_t part = 0; part < multimesh->num_parts(); part++)
    {
      std::shared_ptr<const dolfin::FunctionSpace> V(new Form_L_FunctionSpace_0(multimesh->part(part)));
      add(V);
    }

    // Build multimesh function space
    build();
  }

};

typedef CoefficientSpace_w Form_L_FunctionSpace_1;

typedef CoefficientSpace_w0 Form_L_FunctionSpace_2;

typedef CoefficientSpace_K Form_L_FunctionSpace_3;

typedef CoefficientSpace_Mu Form_L_FunctionSpace_4;

typedef CoefficientSpace_Kil Form_L_FunctionSpace_5;

typedef CoefficientSpace_Etal Form_L_FunctionSpace_6;

typedef CoefficientSpace_Kig Form_L_FunctionSpace_7;

typedef CoefficientSpace_Etag Form_L_FunctionSpace_8;

typedef CoefficientSpace_rhoL Form_L_FunctionSpace_9;

typedef CoefficientSpace_g Form_L_FunctionSpace_10;

typedef CoefficientSpace_pe Form_L_FunctionSpace_11;

typedef CoefficientSpace_M Form_L_FunctionSpace_12;

typedef CoefficientSpace_m Form_L_FunctionSpace_13;

class Form_L: public dolfin::Form
{
public:

  // Constructor
  Form_L(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 13), w(*this, 0), w0(*this, 1), K(*this, 2), Mu(*this, 3), Kil(*this, 4), Etal(*this, 5), Kig(*this, 6), Etag(*this, 7), rhoL(*this, 8), g(*this, 9), pe(*this, 10), M(*this, 11), m(*this, 12)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::make_shared<const dual2d_form_1>();
  }

  // Constructor
  Form_L(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> w0, std::shared_ptr<const dolfin::GenericFunction> K, std::shared_ptr<const dolfin::GenericFunction> Mu, std::shared_ptr<const dolfin::GenericFunction> Kil, std::shared_ptr<const dolfin::GenericFunction> Etal, std::shared_ptr<const dolfin::GenericFunction> Kig, std::shared_ptr<const dolfin::GenericFunction> Etag, std::shared_ptr<const dolfin::GenericFunction> rhoL, std::shared_ptr<const dolfin::GenericFunction> g, std::shared_ptr<const dolfin::GenericFunction> pe, std::shared_ptr<const dolfin::GenericFunction> M, std::shared_ptr<const dolfin::GenericFunction> m):
    dolfin::Form(1, 13), w(*this, 0), w0(*this, 1), K(*this, 2), Mu(*this, 3), Kil(*this, 4), Etal(*this, 5), Kig(*this, 6), Etag(*this, 7), rhoL(*this, 8), g(*this, 9), pe(*this, 10), M(*this, 11), m(*this, 12)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->w0 = w0;
    this->K = K;
    this->Mu = Mu;
    this->Kil = Kil;
    this->Etal = Etal;
    this->Kig = Kig;
    this->Etag = Etag;
    this->rhoL = rhoL;
    this->g = g;
    this->pe = pe;
    this->M = M;
    this->m = m;

    _ufc_form = std::make_shared<const dual2d_form_1>();
  }

  // Destructor
  ~Form_L()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "w0")
      return 1;
    else if (name == "K")
      return 2;
    else if (name == "Mu")
      return 3;
    else if (name == "Kil")
      return 4;
    else if (name == "Etal")
      return 5;
    else if (name == "Kig")
      return 6;
    else if (name == "Etag")
      return 7;
    else if (name == "rhoL")
      return 8;
    else if (name == "g")
      return 9;
    else if (name == "pe")
      return 10;
    else if (name == "M")
      return 11;
    else if (name == "m")
      return 12;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "w0";
    case 2:
      return "K";
    case 3:
      return "Mu";
    case 4:
      return "Kil";
    case 5:
      return "Etal";
    case 6:
      return "Kig";
    case 7:
      return "Etag";
    case 8:
      return "rhoL";
    case 9:
      return "g";
    case 10:
      return "pe";
    case 11:
      return "M";
    case 12:
      return "m";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_L_FunctionSpace_0 TestSpace;
  typedef Form_L_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_L_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_L_FunctionSpace_2 CoefficientSpace_w0;
  typedef Form_L_FunctionSpace_3 CoefficientSpace_K;
  typedef Form_L_FunctionSpace_4 CoefficientSpace_Mu;
  typedef Form_L_FunctionSpace_5 CoefficientSpace_Kil;
  typedef Form_L_FunctionSpace_6 CoefficientSpace_Etal;
  typedef Form_L_FunctionSpace_7 CoefficientSpace_Kig;
  typedef Form_L_FunctionSpace_8 CoefficientSpace_Etag;
  typedef Form_L_FunctionSpace_9 CoefficientSpace_rhoL;
  typedef Form_L_FunctionSpace_10 CoefficientSpace_g;
  typedef Form_L_FunctionSpace_11 CoefficientSpace_pe;
  typedef Form_L_FunctionSpace_12 CoefficientSpace_M;
  typedef Form_L_FunctionSpace_13 CoefficientSpace_m;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner w0;
  dolfin::CoefficientAssigner K;
  dolfin::CoefficientAssigner Mu;
  dolfin::CoefficientAssigner Kil;
  dolfin::CoefficientAssigner Etal;
  dolfin::CoefficientAssigner Kig;
  dolfin::CoefficientAssigner Etag;
  dolfin::CoefficientAssigner rhoL;
  dolfin::CoefficientAssigner g;
  dolfin::CoefficientAssigner pe;
  dolfin::CoefficientAssigner M;
  dolfin::CoefficientAssigner m;
};

class MultiMeshForm_L: public dolfin::MultiMeshForm
{
public:

  // Constructor
  MultiMeshForm_L(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0):
    dolfin::MultiMeshForm(V0), w(*this, 0), w0(*this, 1), K(*this, 2), Mu(*this, 3), Kil(*this, 4), Etal(*this, 5), Kig(*this, 6), Etag(*this, 7), rhoL(*this, 8), g(*this, 9), pe(*this, 10), M(*this, 11), m(*this, 12)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_L(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients

  }

  // Constructor
  MultiMeshForm_L(std::shared_ptr<const dolfin::MultiMeshFunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> w0, std::shared_ptr<const dolfin::GenericFunction> K, std::shared_ptr<const dolfin::GenericFunction> Mu, std::shared_ptr<const dolfin::GenericFunction> Kil, std::shared_ptr<const dolfin::GenericFunction> Etal, std::shared_ptr<const dolfin::GenericFunction> Kig, std::shared_ptr<const dolfin::GenericFunction> Etag, std::shared_ptr<const dolfin::GenericFunction> rhoL, std::shared_ptr<const dolfin::GenericFunction> g, std::shared_ptr<const dolfin::GenericFunction> pe, std::shared_ptr<const dolfin::GenericFunction> M, std::shared_ptr<const dolfin::GenericFunction> m):
    dolfin::MultiMeshForm(V0), w(*this, 0), w0(*this, 1), K(*this, 2), Mu(*this, 3), Kil(*this, 4), Etal(*this, 5), Kig(*this, 6), Etag(*this, 7), rhoL(*this, 8), g(*this, 9), pe(*this, 10), M(*this, 11), m(*this, 12)
  {
    // Create and add standard forms
    std::size_t num_parts = V0->num_parts(); // assume all equal and pick first
    for (std::size_t part = 0; part < num_parts; part++)
    {
      std::shared_ptr<dolfin::Form> a(new Form_L(V0->part(part)));
    add(a);

    }
    // Build multimesh form
    build();

    /// Assign coefficients
    this->w = w;
    this->w0 = w0;
    this->K = K;
    this->Mu = Mu;
    this->Kil = Kil;
    this->Etal = Etal;
    this->Kig = Kig;
    this->Etag = Etag;
    this->rhoL = rhoL;
    this->g = g;
    this->pe = pe;
    this->M = M;
    this->m = m;

  }

  // Destructor
  ~MultiMeshForm_L()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "w0")
      return 1;
    else if (name == "K")
      return 2;
    else if (name == "Mu")
      return 3;
    else if (name == "Kil")
      return 4;
    else if (name == "Etal")
      return 5;
    else if (name == "Kig")
      return 6;
    else if (name == "Etag")
      return 7;
    else if (name == "rhoL")
      return 8;
    else if (name == "g")
      return 9;
    else if (name == "pe")
      return 10;
    else if (name == "M")
      return 11;
    else if (name == "m")
      return 12;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "w0";
    case 2:
      return "K";
    case 3:
      return "Mu";
    case 4:
      return "Kil";
    case 5:
      return "Etal";
    case 6:
      return "Kig";
    case 7:
      return "Etag";
    case 8:
      return "rhoL";
    case 9:
      return "g";
    case 10:
      return "pe";
    case 11:
      return "M";
    case 12:
      return "m";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_L_FunctionSpace_0 TestSpace;
  typedef Form_L_MultiMeshFunctionSpace_0 MultiMeshTestSpace;
  typedef Form_L_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_L_FunctionSpace_2 CoefficientSpace_w0;
  typedef Form_L_FunctionSpace_3 CoefficientSpace_K;
  typedef Form_L_FunctionSpace_4 CoefficientSpace_Mu;
  typedef Form_L_FunctionSpace_5 CoefficientSpace_Kil;
  typedef Form_L_FunctionSpace_6 CoefficientSpace_Etal;
  typedef Form_L_FunctionSpace_7 CoefficientSpace_Kig;
  typedef Form_L_FunctionSpace_8 CoefficientSpace_Etag;
  typedef Form_L_FunctionSpace_9 CoefficientSpace_rhoL;
  typedef Form_L_FunctionSpace_10 CoefficientSpace_g;
  typedef Form_L_FunctionSpace_11 CoefficientSpace_pe;
  typedef Form_L_FunctionSpace_12 CoefficientSpace_M;
  typedef Form_L_FunctionSpace_13 CoefficientSpace_m;

  // Coefficients
  dolfin::MultiMeshCoefficientAssigner w;
  dolfin::MultiMeshCoefficientAssigner w0;
  dolfin::MultiMeshCoefficientAssigner K;
  dolfin::MultiMeshCoefficientAssigner Mu;
  dolfin::MultiMeshCoefficientAssigner Kil;
  dolfin::MultiMeshCoefficientAssigner Etal;
  dolfin::MultiMeshCoefficientAssigner Kig;
  dolfin::MultiMeshCoefficientAssigner Etag;
  dolfin::MultiMeshCoefficientAssigner rhoL;
  dolfin::MultiMeshCoefficientAssigner g;
  dolfin::MultiMeshCoefficientAssigner pe;
  dolfin::MultiMeshCoefficientAssigner M;
  dolfin::MultiMeshCoefficientAssigner m;
};

// Class typedefs
typedef Form_a BilinearForm;
typedef MultiMeshForm_a MultiMeshBilinearForm;
typedef Form_a JacobianForm;
typedef MultiMeshForm_a MultiMeshJacobianForm;
typedef Form_L LinearForm;
typedef MultiMeshForm_L MultiMeshLinearForm;
typedef Form_L ResidualForm;
typedef MultiMeshForm_L MultiMeshResidualForm;
typedef Form_a::TestSpace FunctionSpace;
typedef Form_a::MultiMeshTestSpace MultiMeshFunctionSpace;

}

#endif
